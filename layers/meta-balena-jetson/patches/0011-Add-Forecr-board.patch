From 5efc647da6ed3c02be25ce9e0fba5e1aa5cc83e9 Mon Sep 17 00:00:00 2001
From: Alexandru Costache <alexandru@balena.io>
Date: Fri, 20 Jan 2023 18:01:29 +0100
Subject: [PATCH 11/11] Add Forecr board

---
 forecr-dsb-nx2-xavier-nx-emmc.coffee          |   44 +
 .../forecr-dsb-nx2-xavier-nx-emmc.conf        |   18 +
 .../files/boot0_t194_nx_forecr.bindiff        |  Bin 0 -> 393456 bytes
 .../files/resinOS-flash194_nxde.xml           |    4 +-
 ...b1-pinmux-p3668-a01_forecr_dsboard_nx2.cfg |  319 ++
 .../tegra194-nxde-flash-dry_35.1.0.bb         |   29 +-
 ...-Add-hup-and-rollback-support-xav-nx.patch |    4 +-
 ...-and-rollback-support-forecr-dsb-nx2.patch |  594 +++
 .../uefi/edk2-firmware-tegra_35.1.0.bbappend  |    5 +
 .../recipes-core/systemd/systemd_%.bbappend   |    6 +
 .../recipes-kernel/linux/jetson-dtbs.bb       |   14 +
 ...0001-Port-Forecr-DSBOARD-NX2-patches.patch | 3502 +++++++++++++++++
 .../0001-fix-kernel-headers-test.patch        |    4 +-
 .../linux/linux-tegra_%.bbappend              |   25 +-
 14 files changed, 4549 insertions(+), 19 deletions(-)
 create mode 100644 forecr-dsb-nx2-xavier-nx-emmc.coffee
 create mode 100644 layers/meta-balena-jetson/conf/machine/forecr-dsb-nx2-xavier-nx-emmc.conf
 create mode 100644 layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/boot0_t194_nx_forecr.bindiff
 create mode 100644 layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/tegra19x-mb1-pinmux-p3668-a01_forecr_dsboard_nx2.cfg
 create mode 100644 layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra/0008-Add-hup-and-rollback-support-forecr-dsb-nx2.patch
 create mode 100644 layers/meta-balena-jetson/recipes-core/systemd/systemd_%.bbappend
 create mode 100644 layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra/0001-Port-Forecr-DSBOARD-NX2-patches.patch

diff --git a/forecr-dsb-nx2-xavier-nx-emmc.coffee b/forecr-dsb-nx2-xavier-nx-emmc.coffee
new file mode 100644
index 0000000..59832eb
--- /dev/null
+++ b/forecr-dsb-nx2-xavier-nx-emmc.coffee
@@ -0,0 +1,44 @@
+deviceTypesCommon = require '@resin.io/device-types/common'
+{ networkOptions, commonImg, instructions } = deviceTypesCommon
+
+BOARD_PREPARE  = 'Put the carrier board in recovery mode'
+FLASH_TOOL = 'Unzip BalenaOS image and use <a href=\"https://github.com/balena-os/jetson-flash\">Jetson Flash</a> on the forecr_dsboard_nx2 branch to provision the device.'
+DONE_FLASHING  = 'After flashing is completed, please wait until the board is rebooted'
+module.exports =
+	version: 1
+	slug: 'forecr-dsb-nx2-xavier-nx-emmc'
+	name: 'Forecr DSBOARD NX2 Xavier NX eMMC'
+	arch: 'aarch64'
+	state: 'released'
+	community: true
+
+	instructions: [
+		BOARD_PREPARE
+		FLASH_TOOL
+		DONE_FLASHING
+	]
+
+	gettingStartedLink:
+		windows: 'https://docs.balena.io/jetson-xavier-nx-devkit-emmc/nodejs/getting-started/#adding-your-first-device'
+		osx: 'https://docs.balena.io/jetson-xavier-nx-devkit-emmc/nodejs/getting-started/#adding-your-first-device'
+		linux: 'https://docs.balena.io/jetson-xavier-nx-devkit-emmc/nodejs/getting-started/#adding-your-first-device'
+
+	supportsBlink: false
+
+	yocto:
+		machine: 'forecr-dsb-nx2-xavier-nx-emmc'
+		image: 'balena-image'
+		fstype: 'balenaos-img'
+		version: 'yocto-kirkstone'
+		deployArtifact: 'balena-image-forecr-dsb-nx2-xavier-nx-emmc.balenaos-img'
+		compressed: true
+
+	options: [ networkOptions.group ]
+
+	configuration:
+		config:
+			partition:
+				primary: 15
+			path: '/config.json'
+
+	initialization: commonImg.initialization
diff --git a/layers/meta-balena-jetson/conf/machine/forecr-dsb-nx2-xavier-nx-emmc.conf b/layers/meta-balena-jetson/conf/machine/forecr-dsb-nx2-xavier-nx-emmc.conf
new file mode 100644
index 0000000..e94ddff
--- /dev/null
+++ b/layers/meta-balena-jetson/conf/machine/forecr-dsb-nx2-xavier-nx-emmc.conf
@@ -0,0 +1,18 @@
+#@TYPE: Machine
+#@NAME: Forecr DSBOARD NX2 eMMC
+##@DESCRIPTION: Forecr DSBOARD-NX2 Carrier Board for Nvidia Jetson Xavier NX eMMC
+#
+
+MACHINEOVERRIDES = "jetson-xavier-nx-devkit-emmc:${MACHINE}"
+include conf/machine/jetson-xavier-nx-devkit-emmc.conf
+
+# work-around for https://github.com/OE4T/meta-tegra/issues/400
+MACHINEOVERRIDES := "${@'${MACHINEOVERRIDES}'.replace(':${MACHINE}',':jetson-xavier-nx-devkit-emmc:${MACHINE}')}"
+
+# Uncomment this only if the dtb needs to be rebuilt.
+KERNEL_DEVICETREE = "tegra194-p3668-all-p3509-0000.dtb \
+    tegra194-p3668-dsboard-nx2-0000.dtb \
+    tegra194-p3668-dsboard-nx2-0000-imx477.dtb \
+    tegra194-p3668-dsboard-nx2-0000-rev121.dtb \
+    tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dtb \
+"
diff --git a/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/boot0_t194_nx_forecr.bindiff b/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/boot0_t194_nx_forecr.bindiff
new file mode 100644
index 0000000000000000000000000000000000000000..d29c7bbb23f8881814c3559895bfdbd7d74e2552
GIT binary patch
literal 393456
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

literal 0
HcmV?d00001

diff --git a/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/resinOS-flash194_nxde.xml b/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/resinOS-flash194_nxde.xml
index dbe9f5f..1a8047c 100644
--- a/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/resinOS-flash194_nxde.xml
+++ b/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/resinOS-flash194_nxde.xml
@@ -156,7 +156,7 @@
             <file_system_attribute> 0 </file_system_attribute>
             <allocation_attribute> 8 </allocation_attribute>
             <percent_reserved> 0 </percent_reserved>
-            <filename> tegra194-p3668-all-p3509-0000.dtb </filename>
+            <filename> DTB_NAME </filename>
             <description> **Required.** Chain A; contains Bootloader device tree blob
               (DTB). </description>
         </partition>
@@ -370,7 +370,7 @@
             <file_system_attribute> 0 </file_system_attribute>
             <allocation_attribute> 8 </allocation_attribute>
             <percent_reserved> 0 </percent_reserved>
-            <filename> tegra194-p3668-all-p3509-0000.dtb </filename>
+            <filename> DTB_NAME </filename>
             <description> **Required.** Chain B; contains Bootloader device tree blob
               (DTB). </description>
         </partition>
diff --git a/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/tegra19x-mb1-pinmux-p3668-a01_forecr_dsboard_nx2.cfg b/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/tegra19x-mb1-pinmux-p3668-a01_forecr_dsboard_nx2.cfg
new file mode 100644
index 0000000..5515f0a
--- /dev/null
+++ b/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/files/tegra19x-mb1-pinmux-p3668-a01_forecr_dsboard_nx2.cfg
@@ -0,0 +1,319 @@
+##
+## Pinmux version 1.0
+## Input pinmux file name: tegra19x-jetson_xavier_nx_module-pinmux.dtsi
+## Input gpio file name: tegra19x-jetson_xavier_nx_module-gpio-default.dtsi
+## Generation date: 2022-10-03 18:27
+## PLEASE DO NOT EDIT THIS FILE
+## This is autogenerated file using the script pinmux-dts2cfg.py
+##
+pinmux.major = 1;
+pinmux.minor = 0;
+#### Pinmux for gpio-input pins ####
+pinmux.0x02213680 = 0x00000001; # CONFIG S4
+pinmux.0x02431020 = 0x00000000; # GPIO aud_mclk_ps4
+pinmux.0x022136e0 = 0x00000001; # CONFIG S7
+pinmux.0x02431008 = 0x00000000; # GPIO soc_gpio32_ps7
+pinmux.0x022138a0 = 0x00000001; # CONFIG T5
+pinmux.0x02431080 = 0x00000000; # GPIO dap5_sclk_pt5
+pinmux.0x022138c0 = 0x00000001; # CONFIG T6
+pinmux.0x02431078 = 0x00000000; # GPIO dap5_dout_pt6
+pinmux.0x022138e0 = 0x00000001; # CONFIG T7
+pinmux.0x02431070 = 0x00000000; # GPIO dap5_din_pt7
+pinmux.0x02213a00 = 0x00000001; # CONFIG U0
+pinmux.0x02431068 = 0x00000000; # GPIO dap5_fs_pu0
+pinmux.0x02214000 = 0x00000001; # CONFIG G0
+pinmux.0x02434058 = 0x00000000; # GPIO soc_gpio00_pg0
+pinmux.0x02214080 = 0x00000001; # CONFIG G4
+pinmux.0x02434070 = 0x00000000; # GPIO soc_gpio08_pg4
+pinmux.0x022140e0 = 0x00000001; # CONFIG G7
+pinmux.0x02434088 = 0x00000000; # GPIO soc_gpio11_pg7
+pinmux.0x02214260 = 0x00000001; # CONFIG H3
+pinmux.0x02434038 = 0x00000000; # GPIO uart4_tx_ph3
+pinmux.0x022142a0 = 0x00000001; # CONFIG H5
+pinmux.0x02434028 = 0x00000000; # GPIO uart4_rts_ph5
+pinmux.0x02212200 = 0x00000001; # CONFIG Y0
+pinmux.0x0243d048 = 0x00000000; # GPIO spi3_sck_py0
+pinmux.0x02212220 = 0x00000001; # CONFIG Y1
+pinmux.0x0243d008 = 0x00000000; # GPIO spi3_miso_py1
+pinmux.0x02212240 = 0x00000001; # CONFIG Y2
+pinmux.0x0243d060 = 0x00000000; # GPIO spi3_mosi_py2
+pinmux.0x02212260 = 0x00000001; # CONFIG Y3
+pinmux.0x0243d018 = 0x00000000; # GPIO spi3_cs0_py3
+pinmux.0x02212280 = 0x00000001; # CONFIG Y4
+pinmux.0x0243d028 = 0x00000000; # GPIO spi3_cs1_py4
+pinmux.0x022122a0 = 0x00000001; # CONFIG Y5
+pinmux.0x0243d098 = 0x00000000; # GPIO uart5_tx_py5
+pinmux.0x022122e0 = 0x00000001; # CONFIG Y7
+pinmux.0x0243d0a0 = 0x00000000; # GPIO uart5_rts_py7
+pinmux.0x02212420 = 0x00000001; # CONFIG Z1
+pinmux.0x0243d0b0 = 0x00000000; # GPIO usb_vbus_en0_pz1
+pinmux.0x022124e0 = 0x00000001; # CONFIG Z7
+pinmux.0x0243d050 = 0x00000000; # GPIO spi1_cs1_pz7
+pinmux.0x0c2f1000 = 0x00000001; # CONFIG EE0
+pinmux.0x0c301010 = 0x00000000; # GPIO safe_state_pee0
+pinmux.0x0c2f1080 = 0x00000001; # CONFIG EE4
+pinmux.0x0c301038 = 0x00000000; # GPIO power_on_pee4
+pinmux.0x0c2f1280 = 0x00000001; # CONFIG CC4
+pinmux.0x0c302000 = 0x00000000; # GPIO touch_clk_pcc4
+pinmux.0x02212c20 = 0x00000001; # CONFIG Q1
+pinmux.0x02430058 = 0x00000000; # GPIO soc_gpio21_pq1
+pinmux.0x02212c60 = 0x00000001; # CONFIG Q3
+pinmux.0x02430068 = 0x00000000; # GPIO soc_gpio23_pq3
+pinmux.0x02212ca0 = 0x00000001; # CONFIG Q5
+pinmux.0x02430028 = 0x00000000; # GPIO soc_gpio41_pq5
+pinmux.0x02212cc0 = 0x00000001; # CONFIG Q6
+pinmux.0x02430030 = 0x00000000; # GPIO soc_gpio42_pq6
+pinmux.0x02212e00 = 0x00000001; # CONFIG R0
+pinmux.0x02430040 = 0x00000000; # GPIO soc_gpio44_pr0
+pinmux.0x02212e80 = 0x00000001; # CONFIG R4
+pinmux.0x02430098 = 0x00000000; # GPIO uart1_rts_pr4
+pinmux.0x02212ea0 = 0x00000001; # CONFIG R5
+pinmux.0x02430090 = 0x00000000; # GPIO uart1_cts_pr5
+pinmux.0x02213240 = 0x00000001; # CONFIG L2
+pinmux.0x02437008 = 0x00000000; # GPIO pex_wake_n_pl2
+pinmux.0x02212820 = 0x00000001; # CONFIG N1
+pinmux.0x02440020 = 0x00000000; # GPIO soc_gpio54_pn1
+#### Pinmux for gpio-output-low pins ####
+pinmux.0x02214040 = 0x00000003; # CONFIG G2
+pinmux.0x0221404c = 0x00000000; # CONTROL G2
+pinmux.0x02214050 = 0x00000000; # OUTPUT G2
+pinmux.0x02434048 = 0x00000000; # GPIO soc_gpio02_pg2
+pinmux.0x02212000 = 0x00000003; # CONFIG X0
+pinmux.0x0221200c = 0x00000000; # CONTROL X0
+pinmux.0x02212010 = 0x00000000; # OUTPUT X0
+pinmux.0x0243d000 = 0x00000000; # GPIO gpu_pwr_req_px0
+pinmux.0x0c2f16a0 = 0x00000003; # CONFIG AA5
+pinmux.0x0c2f16ac = 0x00000000; # CONTROL AA5
+pinmux.0x0c2f16b0 = 0x00000000; # OUTPUT AA5
+pinmux.0x0c303028 = 0x00000000; # GPIO can0_en_paa5
+pinmux.0x0c2f1200 = 0x00000003; # CONFIG CC0
+pinmux.0x0c2f120c = 0x00000000; # CONTROL CC0
+pinmux.0x0c2f1210 = 0x00000000; # OUTPUT CC0
+pinmux.0x0c302048 = 0x00000000; # GPIO spi2_sck_pcc0
+pinmux.0x0c2f1240 = 0x00000003; # CONFIG CC2
+pinmux.0x0c2f124c = 0x00000000; # CONTROL CC2
+pinmux.0x0c2f1250 = 0x00000000; # OUTPUT CC2
+pinmux.0x0c302028 = 0x00000000; # GPIO spi2_mosi_pcc2
+pinmux.0x0c2f1260 = 0x00000003; # CONFIG CC3
+pinmux.0x0c2f126c = 0x00000000; # CONTROL CC3
+pinmux.0x0c2f1270 = 0x00000000; # OUTPUT CC3
+pinmux.0x0c302038 = 0x00000000; # GPIO spi2_cs0_pcc3
+pinmux.0x02212a80 = 0x00000003; # CONFIG P4
+pinmux.0x02212a8c = 0x00000000; # CONTROL P4
+pinmux.0x02212a90 = 0x00000000; # OUTPUT P4
+pinmux.0x02430070 = 0x00000000; # GPIO soc_gpio04_pp4
+pinmux.0x02212aa0 = 0x00000003; # CONFIG P5
+pinmux.0x02212aac = 0x00000000; # CONTROL P5
+pinmux.0x02212ab0 = 0x00000000; # OUTPUT P5
+pinmux.0x02430078 = 0x00000000; # GPIO soc_gpio05_pp5
+pinmux.0x02214e00 = 0x00000003; # CONFIG B0
+pinmux.0x02214e0c = 0x00000000; # CONTROL B0
+pinmux.0x02214e10 = 0x00000000; # OUTPUT B0
+pinmux.0x02446008 = 0x00000000; # GPIO cpu_pwr_req_0_pb0
+#### Pinmux for gpio-output-high pins ####
+pinmux.0x0c2f1220 = 0x00000003; # CONFIG CC1
+pinmux.0x0c2f122c = 0x00000000; # CONTROL CC1
+pinmux.0x0c2f1230 = 0x00000001; # OUTPUT CC1
+pinmux.0x0c302050 = 0x00000000; # GPIO spi2_miso_pcc1
+
+#### Pinmux for used pins ####
+pinmux.0x02431060 = 0x00000440; # dap3_sclk_pt1: i2s3, tristate-disable, input-enable, lpdr-disable
+pinmux.0x02431058 = 0x00000400; # dap3_dout_pt2: i2s3, tristate-disable, input-disable, lpdr-disable
+pinmux.0x02431050 = 0x00000450; # dap3_din_pt3: i2s3, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02431048 = 0x00000440; # dap3_fs_pt4: i2s3, tristate-disable, input-enable, lpdr-disable
+pinmux.0x02438000 = 0x0000a460; # sdmmc1_clk_pj0: sdmmc1, tristate-disable, input-enable, loopback-enable
+pinmux.0x02438008 = 0x0000a448; # sdmmc1_cmd_pj1: sdmmc1, pull-up, tristate-disable, input-enable
+pinmux.0x02438030 = 0x0000a448; # sdmmc1_dat0_pj2: sdmmc1, pull-up, tristate-disable, input-enable
+pinmux.0x02438028 = 0x0000a448; # sdmmc1_dat1_pj3: sdmmc1, pull-up, tristate-disable, input-enable
+pinmux.0x02438020 = 0x0000a448; # sdmmc1_dat2_pj4: sdmmc1, pull-up, tristate-disable, input-enable
+pinmux.0x02438018 = 0x0000a448; # sdmmc1_dat3_pj5: sdmmc1, pull-up, tristate-disable, input-enable
+pinmux.0x0243a030 = 0x0000a460; # sdmmc3_clk_po0: sdmmc3, tristate-disable, input-enable, loopback-enable
+pinmux.0x0243a028 = 0x0000a448; # sdmmc3_cmd_po1: sdmmc3, pull-up, tristate-disable, input-enable
+pinmux.0x0243a018 = 0x0000a448; # sdmmc3_dat0_po2: sdmmc3, pull-up, tristate-disable, input-enable
+pinmux.0x0243a010 = 0x0000a448; # sdmmc3_dat1_po3: sdmmc3, pull-up, tristate-disable, input-enable
+pinmux.0x0243a008 = 0x0000a448; # sdmmc3_dat2_po4: sdmmc3, pull-up, tristate-disable, input-enable
+pinmux.0x0243a000 = 0x0000a448; # sdmmc3_dat3_po5: sdmmc3, pull-up, tristate-disable, input-enable
+pinmux.0x02445058 = 0x00022400; # eqos_txc_pe0: eqos, tristate-disable, input-disable
+pinmux.0x02445018 = 0x00022400; # eqos_td0_pe1: eqos, tristate-disable, input-disable
+pinmux.0x02445010 = 0x00022400; # eqos_td1_pe2: eqos, tristate-disable, input-disable
+pinmux.0x02445008 = 0x00022400; # eqos_td2_pe3: eqos, tristate-disable, input-disable
+pinmux.0x02445000 = 0x00022400; # eqos_td3_pe4: eqos, tristate-disable, input-disable
+pinmux.0x02445068 = 0x00022400; # eqos_tx_ctl_pe5: eqos, tristate-disable, input-disable
+pinmux.0x02445040 = 0x00022450; # eqos_rd0_pe6: eqos, tristate-enable, input-enable
+pinmux.0x02445030 = 0x00022450; # eqos_rd1_pe7: eqos, tristate-enable, input-enable
+pinmux.0x02445028 = 0x00022450; # eqos_rd2_pf0: eqos, tristate-enable, input-enable
+pinmux.0x02445020 = 0x00022470; # eqos_rd3_pf1: eqos, tristate-enable, input-enable
+pinmux.0x02445070 = 0x00022450; # eqos_rx_ctl_pf2: eqos, tristate-enable, input-enable
+pinmux.0x02445060 = 0x00022450; # eqos_rxc_pf3: eqos, tristate-enable, input-enable
+pinmux.0x02445038 = 0x00022440; # eqos_sma_mdio_pf4: eqos, tristate-disable, input-enable
+pinmux.0x02445048 = 0x00022400; # eqos_sma_mdc_pf5: eqos, tristate-disable, input-disable
+pinmux.0x0243b020 = 0x00023460; # qspi0_sck_pc0: qspi0, tristate-disable, input-enable, loopback-enable
+pinmux.0x0243b028 = 0x00023400; # qspi0_cs_n_pc1: qspi0, tristate-disable, input-disable
+pinmux.0x0243b018 = 0x00023440; # qspi0_io0_pc2: qspi0, tristate-disable, input-enable
+pinmux.0x0243b010 = 0x00023440; # qspi0_io1_pc3: qspi0, tristate-disable, input-enable
+pinmux.0x0243b008 = 0x00023440; # qspi0_io2_pc4: qspi0, tristate-disable, input-enable
+pinmux.0x0243b000 = 0x00023440; # qspi0_io3_pc5: qspi0, tristate-disable, input-enable
+pinmux.0x02436008 = 0x00002460; # sdmmc4_clk: sdmmc4, tristate-disable, input-enable, loopback-enable
+pinmux.0x02436010 = 0x00002440; # sdmmc4_cmd: sdmmc4, tristate-disable, input-enable
+pinmux.0x02436058 = 0x00002448; # sdmmc4_dat0: sdmmc4, pull-up, tristate-disable, input-enable
+pinmux.0x02436050 = 0x00002448; # sdmmc4_dat1: sdmmc4, pull-up, tristate-disable, input-enable
+pinmux.0x02436048 = 0x00002448; # sdmmc4_dat2: sdmmc4, pull-up, tristate-disable, input-enable
+pinmux.0x02436040 = 0x00002448; # sdmmc4_dat3: sdmmc4, pull-up, tristate-disable, input-enable
+pinmux.0x02436038 = 0x00002448; # sdmmc4_dat4: sdmmc4, pull-up, tristate-disable, input-enable
+pinmux.0x02436030 = 0x00002448; # sdmmc4_dat5: sdmmc4, pull-up, tristate-disable, input-enable
+pinmux.0x02436028 = 0x00002448; # sdmmc4_dat6: sdmmc4, pull-up, tristate-disable, input-enable
+pinmux.0x02436020 = 0x00002448; # sdmmc4_dat7: sdmmc4, pull-up, tristate-disable, input-enable
+pinmux.0x02436018 = 0x00000450; # sdmmc4_dqs: sdmmc4, tristate-enable, input-enable
+pinmux.0x02434080 = 0x00000410; # soc_gpio10_pg6: gp, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434098 = 0x00000401; # soc_gpio13_ph1: gp, tristate-disable, input-disable, lpdr-disable
+pinmux.0x02434060 = 0x00001540; # gen1_i2c_scl_pi3: i2c1, tristate-disable, input-enable, io_high_voltage-disable, lpdr-enable
+pinmux.0x02434068 = 0x00001540; # gen1_i2c_sda_pi4: i2c1, tristate-disable, input-enable, io_high_voltage-disable, lpdr-enable
+pinmux.0x0243d038 = 0x00000410; # gp_pwm2_px2: gp, tristate-enable, input-disable, lpdr-disable
+pinmux.0x0243d070 = 0x00000400; # uart2_tx_px4: uartb, tristate-disable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0243d078 = 0x00000450; # uart2_rx_px5: uartb, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0243d080 = 0x00000408; # uart2_rts_px6: uartb, pull-up, tristate-disable, input-disable, lpdr-disable
+pinmux.0x0243d088 = 0x00000458; # uart2_cts_px7: uartb, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x0243d040 = 0x00001444; # spi1_sck_pz3: spi1, pull-down, tristate-disable, input-enable, lpdr-disable
+pinmux.0x0243d020 = 0x00001444; # spi1_miso_pz4: spi1, pull-down, tristate-disable, input-enable, lpdr-disable
+pinmux.0x0243d058 = 0x00001444; # spi1_mosi_pz5: spi1, pull-down, tristate-disable, input-enable, lpdr-disable
+pinmux.0x0243d010 = 0x00001408; # spi1_cs0_pz6: spi1, pull-up, tristate-disable, input-disable, lpdr-disable
+pinmux.0x0c301000 = 0x00000400; # shutdown_n: shutdown, tristate-disable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c301018 = 0x00000458; # vcomp_alert_pee1: soc, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x0c301040 = 0x00001440; # pwr_i2c_scl_pee5: i2c5, tristate-disable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c301048 = 0x00001440; # pwr_i2c_sda_pee6: i2c5, tristate-disable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c301028 = 0x00001458; # batt_oc_pee3: soc, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x0c303010 = 0x0000c400; # can0_dout_paa2: can0, tristate-disable, input-disable
+pinmux.0x0c303018 = 0x0000c450; # can0_din_paa3: can0, tristate-enable, input-enable
+pinmux.0x0c302010 = 0x00000400; # uart3_tx_pcc5: uartc, tristate-disable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c302008 = 0x00000450; # uart3_rx_pcc6: uartc, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c302030 = 0x00001560; # gen2_i2c_scl_pcc7: i2c2, tristate-disable, input-enable, io_high_voltage-enable, lpdr-enable
+pinmux.0x0c302040 = 0x00001560; # gen2_i2c_sda_pdd0: i2c2, tristate-disable, input-enable, io_high_voltage-enable, lpdr-enable
+pinmux.0x0c302020 = 0x00001560; # gen8_i2c_scl_pdd1: i2c8, tristate-disable, input-enable, io_high_voltage-enable, lpdr-enable
+pinmux.0x0c302018 = 0x00001560; # gen8_i2c_sda_pdd2: i2c8, tristate-disable, input-enable, io_high_voltage-enable, lpdr-enable
+pinmux.0x02430008 = 0x00000400; # extperiph1_clk_pp0: extperiph1, tristate-disable, input-disable, lpdr-disable
+pinmux.0x02430000 = 0x00000400; # extperiph2_clk_pp1: extperiph2, tristate-disable, input-disable, lpdr-disable
+pinmux.0x02430018 = 0x00001460; # cam_i2c_scl_pp2: i2c3, tristate-disable, input-enable, io_high_voltage-enable, lpdr-disable
+pinmux.0x02430010 = 0x00001460; # cam_i2c_sda_pp3: i2c3, tristate-disable, input-enable, io_high_voltage-enable, lpdr-disable
+pinmux.0x02430088 = 0x0000045a; # soc_gpio07_pp7: soc, pull-up, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02430060 = 0x00000459; # soc_gpio22_pq2: nv, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x024300a8 = 0x00000400; # uart1_tx_pr2: uarta, tristate-disable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x024300a0 = 0x00000454; # uart1_rx_pr3: uarta, pull-down, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437048 = 0x00000560; # pex_l4_clkreq_n_pl0: pe4, tristate-disable, input-enable, io_high_voltage-enable, lpdr-enable
+pinmux.0x02437050 = 0x00000520; # pex_l4_rst_n_pl1: pe4, tristate-disable, input-disable, io_high_voltage-enable, lpdr-enable
+pinmux.0x02440030 = 0x00000450; # dp_aux_ch0_hpd_pm0: dp, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02440038 = 0x00000450; # dp_aux_ch1_hpd_pm1: dp, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02440050 = 0x00000460; # hdmi_cec_pm4: hdmi, tristate-disable, input-enable, io_high_voltage-enable, lpdr-disable
+pinmux.0x02431020 = 0x00000059; # aud_mclk_ps4: rsvd1, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02431008 = 0x00000058; # soc_gpio32_ps7: rsvd0, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02431080 = 0x00000056; # dap5_sclk_pt5: rsvd2, pull-down, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02431078 = 0x00000056; # dap5_dout_pt6: rsvd2, pull-down, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02431070 = 0x00000057; # dap5_din_pt7: rsvd3, pull-down, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02431068 = 0x00000057; # dap5_fs_pu0: rsvd3, pull-down, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02434058 = 0x00000058; # soc_gpio00_pg0: rsvd0, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02434048 = 0x00000000; # soc_gpio02_pg2: rsvd0, tristate-disable, input-disable, lpdr-disable
+pinmux.0x02434070 = 0x00000050; # soc_gpio08_pg4: rsvd0, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02434088 = 0x00000058; # soc_gpio11_pg7: rsvd0, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02434038 = 0x00000051; # uart4_tx_ph3: rsvd1, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02434028 = 0x00000051; # uart4_rts_ph5: rsvd1, tristate-enable, input-enable, lpdr-disable
+pinmux.0x0243d000 = 0x00000000; # gpu_pwr_req_px0: rsvd0, tristate-disable, input-disable, lpdr-disable
+pinmux.0x0243d048 = 0x00001055; # spi3_sck_py0: rsvd1, pull-down, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0243d008 = 0x00001055; # spi3_miso_py1: rsvd1, pull-down, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0243d060 = 0x00001055; # spi3_mosi_py2: rsvd1, pull-down, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0243d018 = 0x00001055; # spi3_cs0_py3: rsvd1, pull-down, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0243d028 = 0x00001055; # spi3_cs1_py4: rsvd1, pull-down, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0243d098 = 0x00000051; # uart5_tx_py5: rsvd1, tristate-enable, input-enable, lpdr-disable
+pinmux.0x0243d0a0 = 0x00000051; # uart5_rts_py7: rsvd1, tristate-enable, input-enable, lpdr-disable
+pinmux.0x0243d0b0 = 0x00000049; # usb_vbus_en0_pz1: rsvd1, pull-up, tristate-disable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0243d050 = 0x00001059; # spi1_cs1_pz7: rsvd1, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x0c301010 = 0x00000051; # safe_state_pee0: rsvd1, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c301038 = 0x00000058; # power_on_pee4: rsvd0, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x0c303028 = 0x0000c000; # can0_en_paa5: rsvd0, tristate-disable, input-disable
+pinmux.0x0c302048 = 0x00001002; # spi2_sck_pcc0: rsvd2, tristate-disable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c302050 = 0x00001002; # spi2_miso_pcc1: rsvd2, tristate-disable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c302028 = 0x00001002; # spi2_mosi_pcc2: rsvd2, tristate-disable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c302038 = 0x00001002; # spi2_cs0_pcc3: rsvd2, tristate-disable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c302000 = 0x00000056; # touch_clk_pcc4: rsvd2, pull-down, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02430070 = 0x00000000; # soc_gpio04_pp4: rsvd0, tristate-disable, input-disable, lpdr-disable
+pinmux.0x02430078 = 0x00000000; # soc_gpio05_pp5: rsvd0, tristate-disable, input-disable, lpdr-disable
+pinmux.0x02430058 = 0x00000054; # soc_gpio21_pq1: rsvd0, pull-down, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02430068 = 0x00000058; # soc_gpio23_pq3: rsvd0, pull-up, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02430020 = 0x00000426; # soc_gpio40_pq4: rsvd2, pull-down, tristate-disable, input-disable, io_high_voltage-enable, lpdr-disable
+pinmux.0x02430028 = 0x0000005a; # soc_gpio41_pq5: rsvd2, pull-up, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02430030 = 0x0000005a; # soc_gpio42_pq6: rsvd2, pull-up, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02430038 = 0x00000426; # soc_gpio43_pq7: rsvd2, pull-down, tristate-disable, input-disable, io_high_voltage-enable, lpdr-disable
+pinmux.0x02430040 = 0x00000056; # soc_gpio44_pr0: rsvd2, pull-down, tristate-enable, input-enable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02430048 = 0x00000431; # soc_gpio45_pr1: rsvd1, tristate-enable, input-disable, io_high_voltage-enable, lpdr-disable
+pinmux.0x02430098 = 0x00000055; # uart1_rts_pr4: rsvd1, pull-down, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02430090 = 0x00000055; # uart1_cts_pr5: rsvd1, pull-down, tristate-enable, input-enable, lpdr-disable
+pinmux.0x02446008 = 0x00000000; # cpu_pwr_req_0_pb0: rsvd0, tristate-disable, input-disable, lpdr-disable
+pinmux.0x02437008 = 0x00000178; # pex_wake_n_pl2: rsvd0, pull-up, tristate-enable, input-enable, io_high_voltage-enable, lpdr-enable
+pinmux.0x02440020 = 0x00000054; # soc_gpio54_pn1: rsvd0, pull-down, tristate-enable, input-enable, lpdr-disable
+#### Pinmux for unused pins for low-power configuration ####
+pinmux.0x02431040 = 0x00000415; # dap1_sclk_ps0: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02431038 = 0x00000415; # dap1_dout_ps1: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02431030 = 0x00000415; # dap1_din_ps2: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02431028 = 0x00000415; # dap1_fs_ps3: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02431018 = 0x00000414; # soc_gpio30_ps5: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02431010 = 0x00000414; # soc_gpio31_ps6: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02431000 = 0x00000414; # soc_gpio33_pt0: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x0243b050 = 0x00023435; # qspi1_sck_pc6: rsvd1, pull-down, tristate-enable, input-disable, loopback-enable
+pinmux.0x0243b058 = 0x00023415; # qspi1_cs_n_pc7: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x0243b048 = 0x00023415; # qspi1_io0_pd0: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x0243b040 = 0x00023415; # qspi1_io1_pd1: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x0243b038 = 0x00023415; # qspi1_io2_pd2: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x0243b030 = 0x00023415; # qspi1_io3_pd3: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x02434050 = 0x00000414; # soc_gpio01_pg1: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434040 = 0x00000414; # soc_gpio03_pg3: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434078 = 0x00000414; # soc_gpio09_pg5: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434090 = 0x00000414; # soc_gpio12_ph0: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x024340a0 = 0x00000414; # soc_gpio14_ph2: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434030 = 0x00000415; # uart4_rx_ph4: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434020 = 0x00000415; # uart4_cts_ph6: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434018 = 0x00000415; # dap2_sclk_ph7: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434008 = 0x00000415; # dap2_dout_pi0: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434000 = 0x00000415; # dap2_din_pi1: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02434010 = 0x00000415; # dap2_fs_pi2: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x0243d068 = 0x00000414; # cv_pwr_req_px1: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x0243d030 = 0x00000415; # gp_pwm3_px3: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x0243d090 = 0x00000415; # uart5_rx_py6: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x0243d0a8 = 0x00000415; # uart5_cts_pz0: rsvd1, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x0243d0b8 = 0x00000415; # usb_vbus_en1_pz2: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c301060 = 0x00000415; # ao_retention_n_pee2: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x0c303000 = 0x0000c415; # can1_dout_paa0: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x0c303008 = 0x0000c415; # can1_din_paa1: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x0c303020 = 0x0000c414; # can0_stb_paa4: rsvd0, pull-down, tristate-enable, input-disable
+pinmux.0x0c303030 = 0x0000c414; # can0_wake_paa6: rsvd0, pull-down, tristate-enable, input-disable
+pinmux.0x0c303038 = 0x0000c414; # can0_err_paa7: rsvd0, pull-down, tristate-enable, input-disable
+pinmux.0x0c303040 = 0x0000c414; # can1_stb_pbb0: rsvd0, pull-down, tristate-enable, input-disable
+pinmux.0x0c303048 = 0x0000c414; # can1_en_pbb1: rsvd0, pull-down, tristate-enable, input-disable
+pinmux.0x0c303050 = 0x0000c414; # can1_wake_pbb2: rsvd0, pull-down, tristate-enable, input-disable
+pinmux.0x0c303058 = 0x0000c414; # can1_err_pbb3: rsvd0, pull-down, tristate-enable, input-disable
+pinmux.0x02430080 = 0x00000414; # soc_gpio06_pp6: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02430050 = 0x00000414; # soc_gpio20_pq0: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02432018 = 0x0000c416; # dap6_sclk_pa0: rsvd2, pull-down, tristate-enable, input-disable
+pinmux.0x02432010 = 0x0000c416; # dap6_dout_pa1: rsvd2, pull-down, tristate-enable, input-disable
+pinmux.0x02432008 = 0x0000c416; # dap6_din_pa2: rsvd2, pull-down, tristate-enable, input-disable
+pinmux.0x02432000 = 0x0000c416; # dap6_fs_pa3: rsvd2, pull-down, tristate-enable, input-disable
+pinmux.0x02432038 = 0x0000c416; # dap4_sclk_pa4: rsvd2, pull-down, tristate-enable, input-disable
+pinmux.0x02432030 = 0x0000c416; # dap4_dout_pa5: rsvd2, pull-down, tristate-enable, input-disable
+pinmux.0x02432028 = 0x0000c416; # dap4_din_pa6: rsvd2, pull-down, tristate-enable, input-disable
+pinmux.0x02432020 = 0x0000c416; # dap4_fs_pa7: rsvd2, pull-down, tristate-enable, input-disable
+pinmux.0x02446000 = 0x00000414; # cpu_pwr_req_1_pb1: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02441008 = 0x00022435; # ufs0_ref_clk_pff0: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x02441000 = 0x00022435; # ufs0_rst_pff1: rsvd1, pull-down, tristate-enable, input-disable
+pinmux.0x02437020 = 0x00000415; # pex_l0_clkreq_n_pk0: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437028 = 0x00000415; # pex_l0_rst_n_pk1: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437010 = 0x00000415; # pex_l1_clkreq_n_pk2: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437018 = 0x00000415; # pex_l1_rst_n_pk3: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437000 = 0x00000415; # pex_l2_clkreq_n_pk4: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437030 = 0x00000415; # pex_l2_rst_n_pk5: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437038 = 0x00000415; # pex_l3_clkreq_n_pk6: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437040 = 0x00000415; # pex_l3_rst_n_pk7: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02437058 = 0x00000415; # sata_dev_slp_pl3: rsvd1, pull-down, tristate-enable, input-disable, io_high_voltage-disable, lpdr-disable
+pinmux.0x02440040 = 0x00000416; # dp_aux_ch2_hpd_pm2: rsvd2, pull-down, tristate-enable, input-disable, io_high_voltage-disable
+pinmux.0x02440048 = 0x00000416; # dp_aux_ch3_hpd_pm3: rsvd2, pull-down, tristate-enable, input-disable, io_high_voltage-disable
+pinmux.0x02440000 = 0x00000414; # soc_gpio50_pm5: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02440008 = 0x00000414; # soc_gpio51_pm6: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02440010 = 0x00000414; # soc_gpio52_pm7: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02440018 = 0x00000414; # soc_gpio53_pn0: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
+pinmux.0x02440028 = 0x00000414; # soc_gpio55_pn2: rsvd0, pull-down, tristate-enable, input-disable, lpdr-disable
diff --git a/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/tegra194-nxde-flash-dry_35.1.0.bb b/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/tegra194-nxde-flash-dry_35.1.0.bb
index 58fa7d3..f91bf94 100644
--- a/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/tegra194-nxde-flash-dry_35.1.0.bb
+++ b/layers/meta-balena-jetson/recipes-bsp/tegra-binaries/tegra194-nxde-flash-dry_35.1.0.bb
@@ -6,6 +6,7 @@ LIC_FILES_CHKSUM = "file://${BALENA_COREBASE}/COPYING.Apache-2.0;md5=89aea4e17d9
 IMAGE_ROOTFS_ALIGNMENT ?= "4"
 
 BOOT_BINDIFF="boot0_t194_nx.bindiff"
+BOOT_BINDIFF:forecr-dsb-nx2-xavier-nx-emmc="boot0_t194_nx_forecr.bindiff"
 
 DEPENDS = " \
     coreutils-native \
@@ -26,10 +27,12 @@ SRC_URI = " \
     file://resinOS-flash194_nxde.xml \
     file://partition_specification194_nxde.txt \
     file://${BOOT_BINDIFF} \
+    file://tegra19x-mb1-pinmux-p3668-a01_forecr_dsboard_nx2.cfg \
 "
 
 LNXSIZE ?= "67108864"
 DTBNAME = "tegra194-p3668-all-p3509-0000"
+#DTBNAME:forecr-dsb-nx2-xavier-nx-emmc = "tegra194-p3668-dsboard-nx2-0000"
 KERNEL_DEVICETREE = "${DEPLOY_DIR_IMAGE}/${DTBNAME}.dtb"
 DTBFILE ?= "${@os.path.basename(d.getVar('KERNEL_DEVICETREE', True).split()[0])}"
 
@@ -82,6 +85,7 @@ DEVICE_CONFIG="tegra19x-mb1-bct-device-qspi-p3668.cfg"
 MISC_COLD_BOOT_CONFIG="tegra194-mb1-bct-misc-l4t.cfg"
 MISC_CONFIG="tegra194-mb1-bct-misc-flash.cfg"
 PINMUX_CONFIG="tegra19x-mb1-pinmux-p3668-a01.cfg"
+PINMUX_CONFIG:forecr-dsb-nx2-xavier-nx-emmc="tegra19x-mb1-pinmux-p3668-a01_forecr_dsboard_nx2.cfg"
 GPIOINT_CONFIG="tegra194-mb1-bct-gpioint-p3668-0001-a00.cfg"
 PMIC_CONFIG="tegra194-mb1-bct-pmic-p3668-0001-a00.cfg"
 PMC_CONFIG="tegra19x-mb1-padvoltage-p3668-a01.cfg"
@@ -91,7 +95,7 @@ SCR_COLD_BOOT_CONFIG="tegra194-mb1-bct-scr-cbb-mini-p3668.cfg"
 BR_CMD_CONFIG="tegra194-mb1-bct-reset-p3668-0001-a00.cfg"
 DEV_PARAMS="tegra194-br-bct-qspi-l4t.cfg,tegra194-br-bct_b-qspi-l4t.cfg"
 
-BIN="mb2_bootloader nvtboot_recovery_t194.bin; mts_preboot preboot_c10_prod_cr.bin; mts_mce mce_c10_prod_cr.bin; mts_proper mts_c10_prod_cr.bin; bpmp_fw bpmp-2_t194.bin; bpmp_fw_dtb tegra194-a02-bpmp-p3668-a00_lz4.dtb; spe_fw spe_t194.bin; tos tos-optee_t194.img; eks eks.img; bootloader_dtb tegra194-p3668-all-p3509-0000.dtb"
+BIN="mb2_bootloader nvtboot_recovery_t194.bin; mts_preboot preboot_c10_prod_cr.bin; mts_mce mce_c10_prod_cr.bin; mts_proper mts_c10_prod_cr.bin; bpmp_fw bpmp-2_t194.bin; bpmp_fw_dtb tegra194-a02-bpmp-p3668-a00_lz4.dtb; spe_fw spe_t194.bin; tos tos-optee_t194.img; eks eks.img; bootloader_dtb ${DTBFILE}"
 
 signfile() {
     local destdir="${WORKDIR}/tegraflash"
@@ -108,7 +112,7 @@ signfile() {
         --sdram_config tegra194-mb1-bct-memcfg-p3668-0001-a00.cfg,tegra194-memcfg-sw-override.cfg  \
         --odmdata 0xB8190000   \
         --overlay_dtb L4TConfiguration.dtbo,tegra194-p3668-p3509-overlay.dtbo,L4TRootfsInfo.dtbo  \
-        --bldtb tegra194-p3668-all-p3509-0000.dtb \
+        --bldtb ${DTBFILE} \
         --applet mb1_t194_prod.bin --cmd "sign" \
         --soft_fuses tegra194-mb1-soft-fuses-l4t.cfg  \
         --cfg flash.xml --chip 0x19 \
@@ -157,8 +161,8 @@ do_configure() {
     cp mb1_t194_prod.bin mb1_b_t194_prod.bin
     rm -rf ./rollback
     mkdir -p ./rollback
-    #cp -R ${STAGING_DATADIR}/nv_tegra/rollback/t${@d.getVar('NVIDIA_CHIP')[2:]}x ./rollback/
     cp ${STAGING_DATADIR}/tegraflash/flashvars .
+    cp ${WORKDIR}/tegra19x-mb1-pinmux-p3668-a01_forecr_dsboard_nx2.cfg .
     sed -i -e "s/@OVERLAY_DTB_FILE@/${OVERLAY_DTB_FILE}/" ./flashvars
     for f in ${STAGING_DATADIR}/tegraflash/tegra19[4x]-*.cfg; do
         cp $f .
@@ -186,17 +190,15 @@ do_configure() {
     dtbbuildtime="Aug 10 2022\020:31:55"
     dtboname="Jetson Xavier NX Overlay Support"
     dtbocompat="nvidia,tegra194"
-    cp ${DEPLOY_DIR_IMAGE}/tegra194-p3668-all-p3509-0000.dtb ./tegra194-p3668-all-p3509-0000.dtb
-    # Do not overide this hardcoded dtb for carrier boards, this is used for bldtb in boot0.img
-    fdtput -t s tegra194-p3668-all-p3509-0000.dtb / "nvidia,dtsfilename" $bldtbdtsname
-    fdtput -t s tegra194-p3668-all-p3509-0000.dtb /chosen bootargs $bldtbchosenargs
-    fdtput -t s tegra194-p3668-all-p3509-0000.dtb / compatible $compatible
-    fdtput -t s tegra194-p3668-all-p3509-0000.dtb / "nvidia,dtbbuildtime" "None"
+    cp ${DEPLOY_DIR_IMAGE}/${DTBFILE} .
+    fdtput -t s ${DTBFILE} / "nvidia,dtsfilename" $bldtbdtsname
+    fdtput -t s ${DTBFILE} /chosen bootargs $bldtbchosenargs
+    fdtput -t s ${DTBFILE} / compatible $compatible
+    fdtput -t s ${DTBFILE} / "nvidia,dtbbuildtime" "None"
     fdtput -t s tegra194-p3668-p3509-overlay.dtbo / "nvidia,dtbbuildtime" $dtbbuildtime
     fdtput -t s tegra194-p3668-p3509-overlay.dtbo / "nvidia,dtsfilename" $bldtboname
     fdtput -t s tegra194-p3668-p3509-overlay.dtbo / "overlay-name" $dtboname
     fdtput -t s tegra194-p3668-p3509-overlay.dtbo / "compatible" $dtbocompat
-    fdtget tegra194-p3668-all-p3509-0000.dtb -t s / "nvidia,dtbbuildtime" 
     sed -e"s,MB1FILE,mb1_b_t194_prod.bin,2" flash.xml.in | \
         sed \
         -e"s,LNXFILE_b,$lnxfile," \
@@ -286,7 +288,7 @@ do_configure() {
     dd if=${DEPLOY_DIR_IMAGE}/bootfiles/nvdisp-init.bin_sigheader.default.encrypt of=boot0.img seek=6291456 bs=1 conv=notrunc
 
     #bootloader-dtb
-    dd if=${DEPLOY_DIR_IMAGE}/bootfiles/tegra194-p3668-all-p3509-0000_sigheader.dtb.encrypt of=boot0.img seek=10485760 bs=1 conv=notrunc
+    dd if=${DEPLOY_DIR_IMAGE}/bootfiles/${DTBNAME}_sigheader.dtb.encrypt of=boot0.img seek=10485760 bs=1 conv=notrunc
 
     #secure os
     dd if=${DEPLOY_DIR_IMAGE}/bootfiles/tos-optee_t194_sigheader.img.encrypt of=boot0.img seek=10944512 bs=1 conv=notrunc
@@ -340,7 +342,7 @@ do_configure() {
     dd if=${DEPLOY_DIR_IMAGE}/bootfiles/nvdisp-init.bin_sigheader.default.encrypt of=boot0.img seek=27131904 bs=1 conv=notrunc
 
     #bootloader-dtb_b
-    dd if=${DEPLOY_DIR_IMAGE}/bootfiles/tegra194-p3668-all-p3509-0000_sigheader.dtb.encrypt of=boot0.img seek=31326208 bs=1 conv=notrunc
+    dd if=${DEPLOY_DIR_IMAGE}/bootfiles/${DTBNAME}_sigheader.dtb.encrypt of=boot0.img seek=31326208 bs=1 conv=notrunc
 
     # Patch resulting binary to resemble the one on the flashed device
     dd if=${BOOT_BINDIFF} skip=0 seek=131088 bs=1 count=32 of=boot0.img conv=notrunc
@@ -364,6 +366,8 @@ do_configure() {
     dd if=${BOOT_BINDIFF} skip=52352 seek=33423360 bs=1 count=128 of=boot0.img conv=notrunc
     dd if=${BOOT_BINDIFF} skip=52480 seek=33537536 bs=1 count=16896 of=boot0.img conv=notrunc
     dd if=${BOOT_BINDIFF} skip=69376 seek=10821952 bs=1 count=64 of=boot0.img conv=notrunc
+    dd if=${BOOT_BINDIFF} skip=69440 seek=10489856 bs=1 count=324016 of=boot0.img conv=notrunc
+    dd if=${BOOT_BINDIFF} skip=69440 seek=31330304 bs=1 count=324016 of=boot0.img conv=notrunc
     cp boot0.img ${DEPLOY_DIR_IMAGE}/bootfiles/
 }
 
@@ -416,4 +420,3 @@ do_populate_lic[depends] += "tegra-binaries:do_unpack"
 
 addtask do_deploy before do_package after do_install
 
-COMPATIBLE_MACHINE = "jetson-xavier"
diff --git a/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra/0007-Add-hup-and-rollback-support-xav-nx.patch b/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra/0007-Add-hup-and-rollback-support-xav-nx.patch
index 13f73f7..5a33fb5 100644
--- a/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra/0007-Add-hup-and-rollback-support-xav-nx.patch
+++ b/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra/0007-Add-hup-and-rollback-support-xav-nx.patch
@@ -226,7 +226,7 @@ Index: edk2-tegra/edk2-nvidia/Silicon/NVIDIA/Application/L4TLauncher/L4TLauncher
 +              /* Replace "FDT default" with the default Oring AGX device-tree path as fall-back in case the extra_uEnv.txt-defined dtb cannot be loaded */
 +              FreePool(BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath);
 +              BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath = AllocateZeroPool(MAX_DTB_PATH_LEN);
-+              UnicodeSPrint (BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath, MAX_DTB_PATH_LEN - 1, L"/boot/%s\0", DEFAULT_AGX_ORIN_DTB_NAME);
++              UnicodeSPrint (BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath, MAX_DTB_PATH_LEN - 1, L"/boot/%s\0", DEFAULT_XAV_NX_DTB_NAME);
 +
 +              /* Check if a device-tree name is set in extra_uEnv.txt */
 +              CHAR16 *ExtrauEnvDtb = NULL;
@@ -576,7 +576,7 @@ Index: edk2-tegra/edk2-nvidia/Silicon/NVIDIA/Application/L4TLauncher/L4TLauncher
  #define RECOVERY_BASE_NAME             L"recovery"
  #define RECOVERY_DTB_BASE_NAME         L"recovery-dtb"
 -
-+#define DEFAULT_AGX_ORIN_DTB_NAME      L"tegra194-p3668-all-p3509-0000.dtb"
++#define DEFAULT_XAV_NX_DTB_NAME        L"tegra194-p3668-all-p3509-0000.dtb"
  #define EXTLINUX_KEY_TIMEOUT           L"TIMEOUT"
  #define EXTLINUX_KEY_DEFAULT           L"DEFAULT"
  #define EXTLINUX_KEY_MENU_TITLE        L"MENU TITLE"
diff --git a/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra/0008-Add-hup-and-rollback-support-forecr-dsb-nx2.patch b/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra/0008-Add-hup-and-rollback-support-forecr-dsb-nx2.patch
new file mode 100644
index 0000000..423ccfb
--- /dev/null
+++ b/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra/0008-Add-hup-and-rollback-support-forecr-dsb-nx2.patch
@@ -0,0 +1,594 @@
+L4TLauncher: Add HUP and rollbacks support
+
+L4TLauncher is loaded by the UEFI firmware from
+the resin-boot partition. The launcher's name
+is BOOTAARCH64.efi.
+
+With this patch, the Nvidia bootloader parses resinos_uEnv.txt,
+extra_uEnv.txt and bootcount.env in order to load the
+extlinux.conf and the selected dtb from the current active
+rootfs.
+
+The A/B rootfs switch logic implemented in this change
+is the same as the one that exists in balenaOS u-boot and is
+compatible with the dtb selection mechanism implemented in the
+Supervisor for the rest of the boards that use u-boot.
+
+This patch uses the Xavier NX Devkit eMMC partition layout.
+
+Upstream-status: Inappropriate [configuration]
+Signed-off-by: Alexandru Costache <alexandru@balena.io>
+Index: edk2-tegra/edk2-nvidia/Silicon/NVIDIA/Application/L4TLauncher/L4TLauncher.c
+===================================================================
+--- edk2-tegra.orig/edk2-nvidia/Silicon/NVIDIA/Application/L4TLauncher/L4TLauncher.c
++++ edk2-tegra/edk2-nvidia/Silicon/NVIDIA/Application/L4TLauncher/L4TLauncher.c
+@@ -395,6 +395,7 @@ UpdateBootCfgFile (
+   }
+ 
+   Status = FileHandleWrite (FileHandle, &CorrectSize, CorrectPartitionContent);
++
+   if (EFI_ERROR (Status)) {
+     ErrorPrint (L"%a: Failed to write file content\r\n", __FUNCTION__);
+     return Status;
+@@ -906,6 +907,7 @@ CheckCommandString (
+ 
+   if (StrnCmp (CommandLine, Key, StrLen (Key)) == 0) {
+     Value = CleanExtLinuxLine (CommandLine + StrLen (Key));
++
+     if (Buffer != NULL) {
+       *Buffer = AllocateCopyPool (StrSize (Value), Value);
+       if (*Buffer == NULL) {
+@@ -919,6 +921,130 @@ CheckCommandString (
+   return EFI_NOT_FOUND;
+ }
+ 
++STATIC
++EFI_STATUS
++EFIAPI
++CheckDtbExists (
++  IN EFI_HANDLE             DeviceHandle,
++  IN UINT32                 BootChain,
++  IN CONST CHAR16           *BalenaOSRootFs,
++  IN CONST CHAR16           *DtbPath
++  )
++{
++  EFI_STATUS       Status;
++  EFI_DEVICE_PATH  *FullDevicePath;
++  EFI_DEVICE_PATH  *TmpFullDevicePath;
++  EFI_FILE_HANDLE  FileHandle = NULL;
++  EFI_HANDLE       RootFsHandle;
++
++  if (NULL == BalenaOSRootFs || NULL == DtbPath) {
++      return EFI_INVALID_PARAMETER;
++  }
++
++  Status = FindPartitionInfo (DeviceHandle, BalenaOSRootFs, BootChain, NULL, &RootFsHandle);
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Unable to find partition info\r\n", __FUNCTION__);
++    return Status;
++  }
++
++  FullDevicePath = FileDevicePath (RootFsHandle, DtbPath);
++  if (NULL == FullDevicePath) {
++    ErrorPrint (L"%a: Failed to create file device path\r\n", __FUNCTION__);
++    return EFI_OUT_OF_RESOURCES;
++  }
++
++  TmpFullDevicePath = FullDevicePath;
++  Status = EfiOpenFileByDevicePath (&TmpFullDevicePath, &FileHandle, EFI_FILE_MODE_READ, 0);
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Failed to open dtb file %r\r\n", __FUNCTION__, Status);
++  }
++
++  if (FileHandle != NULL) {
++    FileHandleClose (FileHandle);
++  }
++  return Status;
++}
++
++STATIC
++EFI_STATUS
++EFIAPI
++ProcessExtrauEnv (
++  IN EFI_HANDLE            DeviceHandle,
++  IN UINT32                BootChain,
++  IN CONST CHAR16          *BalenaOSRootFs,
++  OUT CHAR16               **CustomFdtName
++)
++{
++  EFI_STATUS       Status;
++  EFI_HANDLE       BootPartHandle;
++  EFI_DEVICE_PATH  *FullDevicePath;
++  EFI_DEVICE_PATH  *TmpFullDevicePath;
++  EFI_FILE_HANDLE  FileHandle = NULL;
++  CHAR16           *FileLine = NULL;
++  CHAR16           *CleanLine;
++  CHAR16           *DtbName = NULL;
++  BOOLEAN          Ascii;
++
++  Status = FindPartitionInfo (DeviceHandle, BALENA_BOOT_PARTITION, BootChain, NULL, &BootPartHandle);
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Unable to find boot partition\r\n", __FUNCTION__);
++    return Status;
++  }
++
++  FullDevicePath = FileDevicePath (BootPartHandle, BALENA_EXTRA_UENV_FILE);
++
++  if (NULL == FullDevicePath) {
++      ErrorPrint (L"%a: Failed to create file device path to extra_uEnv.txt\r\n", __FUNCTION__);
++      return EFI_OUT_OF_RESOURCES;
++  }
++
++  TmpFullDevicePath = FullDevicePath;
++  Status = EfiOpenFileByDevicePath (&TmpFullDevicePath, &FileHandle, EFI_FILE_MODE_READ, 0);
++
++  if (EFI_ERROR (Status)) {
++      ErrorPrint (L"%a: Failed to open file extra_uEnv.txt: %r\r\n", __FUNCTION__, Status);
++      return Status;
++  }
++
++  while (!FileHandleEof (FileHandle)) {
++    if (FileLine != NULL) {
++      FreePool (FileLine);
++      FileLine = NULL;
++    }
++    FileLine = FileHandleReturnLine (FileHandle, &Ascii);
++
++    if (NULL == FileLine) {
++      break;
++    }
++
++    CleanLine = CleanExtLinuxLine (FileLine);
++    if (*CleanLine != CHAR_NULL) {
++      DtbName = StrStr(CleanLine, L"custom_fdt_file=");
++      if (NULL != DtbName) {
++        DtbName += StrLen(L"custom_fdt_file=");
++        *CustomFdtName = AllocateZeroPool(MAX_DTB_PATH_LEN);
++        UnicodeSPrint (*CustomFdtName, MAX_DTB_PATH_LEN - 1, L"boot\\%s\0", DtbName);
++        Status = CheckDtbExists(DeviceHandle, BootChain, BalenaOSRootFs, *CustomFdtName);
++        if (EFI_ERROR(Status)) {
++          ErrorPrint(L"DTB set in extrauEnv does not exist!\n");
++          return Status;
++        }
++      }
++    }
++
++    if (FileHandle != NULL) {
++      FileHandleClose (FileHandle);
++    }
++
++    if (FileLine != NULL) {
++      FreePool (FileLine);
++      FileLine = NULL;
++    }
++  }
++
++  return EFI_SUCCESS;
++}
++
+ /**
+   Process the extlinux.conf file
+ 
+@@ -936,6 +1062,7 @@ EFIAPI
+ ProcessExtLinuxConfig (
+   IN EFI_HANDLE             DeviceHandle,
+   IN UINT32                 BootChain,
++  IN CONST CHAR16           *BalenaOSRootFs,
+   OUT EXTLINUX_BOOT_CONFIG  *BootConfig,
+   OUT EFI_HANDLE            *RootFsHandle
+   )
+@@ -949,8 +1076,11 @@ ProcessExtLinuxConfig (
+   CHAR16           *Timeout      = NULL;
+   CHAR16           *CbootArg     = NULL;
+   CHAR16           *PostCbootArg = NULL;
++  CONST CHAR16     *RootL = L"root=LABEL=";
+   BOOLEAN          Ascii;
+   UINTN            Index;
++  CHAR16           *UpdatedCmdline = NULL;
++  UINTN            argsSize;
+ 
+   ZeroMem (BootConfig, sizeof (EXTLINUX_BOOT_CONFIG));
+ 
+@@ -958,21 +1088,11 @@ ProcessExtLinuxConfig (
+     return EFI_INVALID_PARAMETER;
+   }
+ 
+-  Status = FindPartitionInfo (DeviceHandle, ROOTFS_BASE_NAME, BootChain, NULL, RootFsHandle);
+-  if (EFI_ERROR (Status)) {
+-    ErrorPrint (L"%a: Unable to find partition info\r\n", __FUNCTION__);
+-    return Status;
+-  }
++  /* Load extlinux.conf from the selected BalenaOS root filesystem */
++  Status = FindPartitionInfo (DeviceHandle, BalenaOSRootFs, BootChain, NULL, RootFsHandle);
+ 
+-  Status = VerifyDetachedCertificateFile (
+-             EXTLINUX_CONF_PATH,
+-             *RootFsHandle,
+-             &FileHandle,
+-             NULL,
+-             NULL
+-             );
+   if (EFI_ERROR (Status)) {
+-    ErrorPrint (L"%a:sds Failed to Authenticate %s (%r)\r\n", __FUNCTION__, EXTLINUX_CONF_PATH, Status);
++    ErrorPrint (L"%a: Unable to find partition info\r\n", __FUNCTION__);
+     return Status;
+   }
+ 
+@@ -1050,11 +1170,48 @@ ProcessExtLinuxConfig (
+         }
+ 
+         Status = CheckCommandString (CleanLine, EXTLINUX_KEY_FDT, &BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath);
++
+         if (!EFI_ERROR (Status)) {
++          /* extlinux.conf contains a "FDT default" entry */
++          if (0 == StrnCmp(BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath, EXTLINUX_GENERIC_FDT, StrLen (EXTLINUX_GENERIC_FDT))) {
++            if (NULL != BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath) {
++              /* Replace "FDT default" with the default Forecr device-tree path as fall-back in case the extra_uEnv.txt-defined dtb cannot be loaded */
++              FreePool(BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath);
++              BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath = AllocateZeroPool(MAX_DTB_PATH_LEN);
++              UnicodeSPrint (BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath, MAX_DTB_PATH_LEN - 1, L"/boot/%s\0", DEFAULT_DSB_NX2_DTB_NAME);
++
++              /* Check if a device-tree name is set in extra_uEnv.txt */
++              CHAR16 *ExtrauEnvDtb = NULL;
++              Status = ProcessExtrauEnv(DeviceHandle, BootChain, BalenaOSRootFs, &ExtrauEnvDtb);
++
++	      if (!EFI_ERROR(Status)) {
++	        /* The device-tree set in extra_uEnv.txt will be loaded */
++	        FreePool(BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath);
++	        BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath = ExtrauEnvDtb;
++	      }
++            }
++         } else {
++             Print(L"Kernel device-tree is %s\n", BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].DtbPath);
++         }
++
+           continue;
+         }
+ 
+         Status = CheckCommandString (CleanLine, EXTLINUX_KEY_APPEND, &BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].BootArgs);
++        argsSize = StrSize (BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].BootArgs);
++        UpdatedCmdline = AllocateZeroPool (argsSize + StrSize(RootL) + StrSize(BalenaOSRootFs) + 2);
++        if (NULL == UpdatedCmdline) {
++            ErrorPrint (L"%a: Failed to allocate memory for updated cmdline %d\r\n", __FUNCTION__);
++            return EFI_OUT_OF_RESOURCES;
++        }
++
++        /* Append root label to cmdline that has been read from the extlinux.conf read from the active rootfs */
++        UnicodeSPrint (UpdatedCmdline, StrSize(RootL) + StrSize(BalenaOSRootFs) + argsSize, L"%s %s%s\0", BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].BootArgs, RootL, BalenaOSRootFs);
++        if (NULL != BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].BootArgs) {
++          FreePool(BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].BootArgs);
++        }
++        BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].BootArgs = UpdatedCmdline;
++
+         if (!EFI_ERROR (Status)) {
+           CbootArg = StrStr (BootConfig->BootOptions[BootConfig->NumberOfBootOptions-1].BootArgs, EXTLINUX_CBOOT_ARG);
+           if (CbootArg != NULL) {
+@@ -2321,6 +2478,221 @@ Exit:
+   return Status;
+ }
+ 
++STATIC
++EFI_STATUS
++EFIAPI
++WriteBootCountFile (
++  IN EFI_HANDLE            DeviceHandle,
++  IN UINT32                BootChain,
++  IN UINT32                BootCountValue
++)
++{
++  EFI_STATUS       Status;
++  EFI_DEVICE_PATH  *FullDevicePath;
++  EFI_DEVICE_PATH  *TmpFullDevicePath;
++  EFI_FILE_HANDLE  FileHandle = NULL;
++  CHAR8            BootCountContent[11];
++  UINTN            BootCountFileSize;
++  EFI_HANDLE       BootPartHandle;
++
++  Status = FindPartitionInfo (DeviceHandle, BALENA_BOOT_PARTITION, BootChain, NULL, &BootPartHandle);
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Unable to find partition resin-boot\r\n", __FUNCTION__);
++    return Status;
++  }
++
++  FullDevicePath = FileDevicePath (BootPartHandle, BALENA_BOOTCOUNT_FILE_PATH);
++  if (NULL == FullDevicePath) {
++    ErrorPrint (L"%a: Failed to create file device path bootcount.env\r\n", __FUNCTION__);
++    return EFI_OUT_OF_RESOURCES;
++  }
++
++  TmpFullDevicePath = FullDevicePath;
++  Status = EfiOpenFileByDevicePath (&TmpFullDevicePath, &FileHandle, EFI_FILE_MODE_READ|EFI_FILE_MODE_WRITE|EFI_FILE_MODE_CREATE, 0);
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Failed to open file bootcount.env: %r\r\n", __FUNCTION__, Status);
++    return Status;
++  }
++
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Failed to set file size to 0\r\n", __FUNCTION__);
++    return Status;
++  }
++
++  BootCountFileSize = AsciiSPrint (BootCountContent, 12, "bootcount=%d\0", BootCountValue);
++  Status = FileHandleWrite (FileHandle, &BootCountFileSize, BootCountContent);
++
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Failed to write bootcount file contents\r\n", __FUNCTION__);
++    return Status;
++  }
++
++  if (FileHandle != NULL) {
++    FileHandleClose (FileHandle);
++  }
++
++  return EFI_SUCCESS;
++}
++
++
++STATIC
++EFI_STATUS
++EFIAPI
++ProcessBootCountValue (
++  IN EFI_HANDLE            DeviceHandle,
++  IN UINT32                BootChain,
++  OUT UINTN                *BootCountValue
++)
++{
++  EFI_STATUS       Status;
++  EFI_DEVICE_PATH  *FullDevicePath;
++  EFI_DEVICE_PATH  *TmpFullDevicePath;
++  EFI_HANDLE       BootPartHandle;
++  EFI_FILE_HANDLE  FileHandle = NULL;
++  CHAR16           *FileLine = NULL;
++  CHAR16           *CleanLine;
++  BOOLEAN          Ascii;
++
++  Status = FindPartitionInfo (DeviceHandle, BALENA_BOOT_PARTITION, BootChain, NULL, &BootPartHandle);
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Could not find partition resin-boot\r\n", __FUNCTION__);
++    return Status;
++  }
++
++  FullDevicePath = FileDevicePath (BootPartHandle, BALENA_BOOTCOUNT_FILE_PATH);
++  if (NULL == FullDevicePath) {
++    ErrorPrint (L"%a: Failed to create file device path for bootcount.env\r\n", __FUNCTION__);
++    return EFI_OUT_OF_RESOURCES;
++  }
++
++  TmpFullDevicePath = FullDevicePath;
++  Status = EfiOpenFileByDevicePath (&TmpFullDevicePath, &FileHandle, EFI_FILE_MODE_READ, 0);
++  if (EFI_ERROR (Status)) {
++    *BootCountValue = 1;
++    Status = WriteBootCountFile (DeviceHandle, BootChain, *BootCountValue);
++
++    if (EFI_ERROR (Status)) {
++      ErrorPrint (L"%a: Failed to write bootcount file contents\r\n", __FUNCTION__);
++      return Status;
++    } else {
++      Print(L"Initialized boot count to 1\r\n");
++    }
++  } else {
++     while (!FileHandleEof (FileHandle)) {
++       if (FileLine != NULL) {
++         FreePool (FileLine);
++         FileLine = NULL;
++       }
++
++       FileLine = FileHandleReturnLine (FileHandle, &Ascii);
++       if (NULL == FileLine) {
++         break;
++       }
++
++       CleanLine = CleanExtLinuxLine (FileLine);
++       if (*CleanLine != CHAR_NULL) {
++         if (StrStr(CleanLine, L"bootcount=")) {
++           *BootCountValue = StrDecimalToUintn(CleanLine + 10);
++           Print(L"%a: BootCount is %d : %s\r\n", __FUNCTION__, *BootCountValue);
++
++           if (FileHandle != NULL) {
++             FileHandleClose (FileHandle);
++           }
++         }
++
++         if (FileLine != NULL) {
++           FreePool (FileLine);
++           FileLine = NULL;
++         }
++
++         Status = WriteBootCountFile (DeviceHandle, BootChain, ++(*BootCountValue));
++         if (EFI_ERROR (Status)) {
++          ErrorPrint (L"%a: Failed to write bootcount file value %d\r\n", __FUNCTION__, *BootCountValue);
++         }
++
++         return Status;
++       }
++     }
++  }
++
++  return EFI_SUCCESS;
++}
++
++
++STATIC
++EFI_STATUS
++EFIAPI
++ProcessResinOSuEnv (
++  IN EFI_HANDLE            DeviceHandle,
++  IN UINT32                BootChain,
++  OUT UINTN                *RootPart,
++  OUT UINTN                *UpgradeAvailable
++)
++{
++  EFI_STATUS       Status;
++  EFI_HANDLE       BootPartHandle;
++  EFI_DEVICE_PATH  *FullDevicePath;
++  EFI_DEVICE_PATH  *TmpFullDevicePath;
++  EFI_FILE_HANDLE  FileHandle = NULL;
++  CHAR16           *FileLine = NULL;
++  CHAR16           *CleanLine;
++  BOOLEAN          Ascii;
++
++  Status = FindPartitionInfo (DeviceHandle, BALENA_BOOT_PARTITION, BootChain, NULL, &BootPartHandle);
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Could not find partition Balena boot partition\r\n", __FUNCTION__);
++    return Status;
++  }
++
++  FullDevicePath = FileDevicePath (BootPartHandle, BALENA_BOOT_CONF_PATH);
++  if (NULL == FullDevicePath) {
++    ErrorPrint (L"%a: Failed to create path for resinOS_uEnvt.xt\r\n", __FUNCTION__);
++    return EFI_OUT_OF_RESOURCES;
++  }
++
++  TmpFullDevicePath = FullDevicePath;
++  Status = EfiOpenFileByDevicePath (&TmpFullDevicePath, &FileHandle, EFI_FILE_MODE_READ, 0);
++  if (EFI_ERROR (Status)) {
++    ErrorPrint (L"%a: Failed to open resinOS_uEnv.txt: %r\r\n", __FUNCTION__, Status);
++    return Status;
++  }
++
++  while (!FileHandleEof (FileHandle)) {
++    if (FileLine != NULL) {
++      FreePool (FileLine);
++      FileLine = NULL;
++    }
++
++    FileLine = FileHandleReturnLine (FileHandle, &Ascii);
++    if (NULL == FileLine) {
++      break;
++    }
++
++    CleanLine = CleanExtLinuxLine (FileLine);
++    if (*CleanLine != CHAR_NULL) {
++      if (StrStr(CleanLine, L"resin_root_part=")) {
++       *RootPart = StrHexToUintn(CleanLine + 16);
++       Print(L"RootPart is 0x%x\r\n", *RootPart);
++      } else if (StrStr(CleanLine, L"upgrade_available=")) {
++        *UpgradeAvailable = StrDecimalToUintn(CleanLine + 18);
++        Print(L"UpgradeAvailable is %d\r\n", *UpgradeAvailable);
++      }
++    }
++  }
++
++  if (FileHandle != NULL) {
++    FileHandleClose (FileHandle);
++  }
++
++  if (FileLine != NULL) {
++    FreePool (FileLine);
++    FileLine = NULL;
++  }
++
++  return EFI_SUCCESS;
++}
++
++
+ /**
+   This is the declaration of an EFI image entry point. This entry point is
+   the same for UEFI Applications, UEFI OS Loaders, and UEFI Drivers, including
+@@ -2350,7 +2722,10 @@ L4TLauncher (
+   EXTLINUX_BOOT_CONFIG       ExtLinuxConfig;
+   UINTN                      ExtLinuxBootOption;
+   UINTN                      Index;
+-
++  CHAR16                     *BalenaOSRootFs = NULL;
++  UINTN                      UpgradeAvailable = 0;
++  UINTN                      BootCountValue = 0;
++  UINTN                      RootFsIndex = BALENA_ROOTFS_INDEX_A;
+   Status = gBS->HandleProtocol (ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID **)&LoadedImage);
+   if (EFI_ERROR (Status)) {
+     ErrorPrint (L"%a: Unable to locate loaded image: %r\r\n", __FUNCTION__, Status);
+@@ -2363,6 +2738,8 @@ L4TLauncher (
+     return Status;
+   }
+ 
++  ErrorPrint(L"BalenaOS: Set BootMode to NVIDIA_L4T_BOOTMODE_DIRECT\r\r\n");
++  BootParams.BootMode = NVIDIA_L4T_BOOTMODE_DIRECT;
+   if (BootParams.BootMode == NVIDIA_L4T_BOOTMODE_GRUB) {
+     ErrorPrint (L"%a: Attempting GRUB Boot\r\n", __FUNCTION__);
+     do {
+@@ -2406,11 +2783,41 @@ L4TLauncher (
+   }
+ 
+   if (BootParams.BootMode == NVIDIA_L4T_BOOTMODE_DIRECT) {
+-    ErrorPrint (L"%a: Attempting Direct Boot\r\n", __FUNCTION__);
++    Print (L"%a: Attempt Direct Boot\r\n", __FUNCTION__);
+     do {
+-      Status = ProcessExtLinuxConfig (LoadedImage->DeviceHandle, BootParams.BootChain, &ExtLinuxConfig, &RootFsDeviceHandle);
++      Status = ProcessResinOSuEnv (LoadedImage->DeviceHandle, BootParams.BootChain, &RootFsIndex, &UpgradeAvailable);
++      if (EFI_ERROR (Status)) {
++         ErrorPrint(L"resinOS_uEnv.txt does not exist\n");
++      }
++
++      Print(L"Current resin_root_part=%d - upgrade_available=%d\r\n", RootFsIndex, UpgradeAvailable);
++      if (1 == UpgradeAvailable) {
++          Status = ProcessBootCountValue (LoadedImage->DeviceHandle, BootParams.BootChain, &BootCountValue);
++          if (EFI_ERROR (Status)) {
++              ErrorPrint(L"%a: Error while processing bootcount value\r\n", __FUNCTION__);
++          }
++          Print (L"%a: BootCountValue is %d\r\n", __FUNCTION__, BootCountValue);
++      }
++
++      /* If boot limit is reached while upgrade_available=1, switch partitions */
++      if (BALENA_OS_BC_LIM <= BootCountValue) {
++         if (BALENA_ROOTFS_INDEX_B == RootFsIndex) {
++            RootFsIndex = BALENA_ROOTFS_INDEX_A;
++         } else {
++            RootFsIndex = BALENA_ROOTFS_INDEX_B;
++         }
++         ErrorPrint(L"%a: Reached bootcount limit, will switch partitions... New index is %d\r\n", __FUNCTION__, RootFsIndex);
++      }
++
++      if (BALENA_ROOTFS_INDEX_B == RootFsIndex) {
++        BalenaOSRootFs = BALENA_ROOTFS_BASE_NAME_B;
++      } else {
++        BalenaOSRootFs = BALENA_ROOTFS_BASE_NAME_A;
++      }
++
++      Status = ProcessExtLinuxConfig (LoadedImage->DeviceHandle, BootParams.BootChain, BalenaOSRootFs, &ExtLinuxConfig, &RootFsDeviceHandle);
+       if (EFI_ERROR (Status)) {
+-        ErrorPrint (L"%a: Unable to process extlinux config: %r\r\n", __FUNCTION__, Status);
++        ErrorPrint (L"%a: ProcessExtLinuxConfig failed on partition %s: %r\r\n", __FUNCTION__, BalenaOSRootFs, Status);
+         BootParams.BootMode = NVIDIA_L4T_BOOTMODE_BOOTIMG;
+         break;
+       }
+Index: edk2-tegra/edk2-nvidia/Silicon/NVIDIA/Application/L4TLauncher/L4TLauncher.h
+===================================================================
+--- edk2-tegra.orig/edk2-nvidia/Silicon/NVIDIA/Application/L4TLauncher/L4TLauncher.h
++++ edk2-tegra/edk2-nvidia/Silicon/NVIDIA/Application/L4TLauncher/L4TLauncher.h
+@@ -31,13 +31,22 @@
+ #define BOOT_OS_VARIABLE_NAME          L"BootChainOsCurrent"
+ #define BOOT_OS_OVERRIDE_VARIABLE_NAME L"BootChainOsOverride"
+ #define ROOTFS_INFO_VARIABLE_NAME      L"RootfsInfo"
+-
+ #define ROOTFS_BASE_NAME               L"APP"
++#define BALENA_ROOTFS_BASE_NAME_A      L"resin-rootA"
++#define BALENA_ROOTFS_BASE_NAME_B      L"resin-rootB"
++#define BALENA_BOOT_PARTITION          L"resin-boot"
++#define BALENA_BOOT_CONF_PATH          L"resinOS_uEnv.txt"
++#define BALENA_BOOTCOUNT_FILE_PATH     L"bootcount.env"
++#define MAX_RESINOS_UENV_SIZE          256
++#define BALENA_ROOTFS_INDEX_A          16
++#define BALENA_ROOTFS_INDEX_B          17
++#define BALENA_OS_BC_LIM               3
++#define BALENA_EXTRA_UENV_FILE         L"extra_uEnv.txt"
+ #define BOOTIMG_BASE_NAME              L"kernel"
+ #define BOOTIMG_DTB_BASE_NAME          L"kernel-dtb"
+ #define RECOVERY_BASE_NAME             L"recovery"
+ #define RECOVERY_DTB_BASE_NAME         L"recovery-dtb"
+-
++#define DEFAULT_DSB_NX2_DTB_NAME       L"tegra194-p3668-dsboard-nx2-0000.dtb"
+ #define EXTLINUX_KEY_TIMEOUT           L"TIMEOUT"
+ #define EXTLINUX_KEY_DEFAULT           L"DEFAULT"
+ #define EXTLINUX_KEY_MENU_TITLE        L"MENU TITLE"
+@@ -47,9 +56,10 @@
+ #define EXTLINUX_KEY_INITRD            L"INITRD"
+ #define EXTLINUX_KEY_FDT               L"FDT"
+ #define EXTLINUX_KEY_APPEND            L"APPEND"
++#define EXTLINUX_GENERIC_FDT           L"default"
+ 
+ #define EXTLINUX_CBOOT_ARG             L"${cbootargs}"
+-
++#define MAX_DTB_PATH_LEN               512 * 2
+ #define MAX_EXTLINUX_OPTIONS           10
+ 
+ /*
diff --git a/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra_35.1.0.bbappend b/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra_35.1.0.bbappend
index b5399ab..16ce9fa 100644
--- a/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra_35.1.0.bbappend
+++ b/layers/meta-balena-jetson/recipes-bsp/uefi/edk2-firmware-tegra_35.1.0.bbappend
@@ -19,6 +19,11 @@ SRC_URI:append:jetson-xavier-nx-devkit = " \
 SRC_URI:append:jetson-xavier-nx-devkit-emmc = " \
     file://0007-Add-hup-and-rollback-support-xav-nx.patch \
 "
+SRC_URI:remove:forecr-dsb-nx2-xavier-nx-emmc = "file://0007-Add-hup-and-rollback-support-xav-nx.patch"
+
+SRC_URI:append:forecr-dsb-nx2-xavier-nx-emmc = " \
+    file://0008-Add-hup-and-rollback-support-forecr-dsb-nx2.patch \
+"
 
 do_deploy:append() {
      mkdir -p ${DEPLOYDIR}/bootfiles/EFI/BOOT/
diff --git a/layers/meta-balena-jetson/recipes-core/systemd/systemd_%.bbappend b/layers/meta-balena-jetson/recipes-core/systemd/systemd_%.bbappend
new file mode 100644
index 0000000..6a0cdd7
--- /dev/null
+++ b/layers/meta-balena-jetson/recipes-core/systemd/systemd_%.bbappend
@@ -0,0 +1,6 @@
+DEPENDS += "acl"
+
+do_install:append() {
+    # It appears that 10s is not enough for high loads after hup
+    sed -i 's/10s/60s/g' ${D}/${sysconfdir}/systemd/system.conf.d/watchdog.conf
+}
diff --git a/layers/meta-balena-jetson/recipes-kernel/linux/jetson-dtbs.bb b/layers/meta-balena-jetson/recipes-kernel/linux/jetson-dtbs.bb
index da70ade..45d1408 100644
--- a/layers/meta-balena-jetson/recipes-kernel/linux/jetson-dtbs.bb
+++ b/layers/meta-balena-jetson/recipes-kernel/linux/jetson-dtbs.bb
@@ -40,3 +40,17 @@ FILES:${PN}:jetson-xavier-nx-devkit-emmc += " \
         /boot/tegra194-p3668-all-p3509-0000.dtb \
 "
 
+do_install:append:forecr-dsb-nx2-xavier-nx-emmc() {
+	install -m 0644 ${DEPLOY_DIR_IMAGE}/tegra194-p3668-dsboard-nx2-0000.dtb ${D}/boot/tegra194-p3668-dsboard-nx2-0000.dtb
+	install -m 0644 ${DEPLOY_DIR_IMAGE}/tegra194-p3668-dsboard-nx2-0000-imx477.dtb ${D}/boot/tegra194-p3668-dsboard-nx2-0000-imx477.dtb
+	install -m 0644 ${DEPLOY_DIR_IMAGE}/tegra194-p3668-dsboard-nx2-0000-rev121.dtb ${D}/boot/tegra194-p3668-dsboard-nx2-0000-rev121.dtb
+        install -m 0644 ${DEPLOY_DIR_IMAGE}/tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dtb ${D}/boot/tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dtb
+}
+
+FILES:${PN}:forecr-dsb-nx2-xavier-nx-emmc += " \
+        /boot/tegra194-p3668-all-p3509-0000.dtb \
+	/boot/tegra194-p3668-dsboard-nx2-0000.dtb \
+	/boot/tegra194-p3668-dsboard-nx2-0000-imx477.dtb \
+	/boot/tegra194-p3668-dsboard-nx2-0000-rev121.dtb \
+	/boot/tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dtb \
+"
diff --git a/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra/0001-Port-Forecr-DSBOARD-NX2-patches.patch b/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra/0001-Port-Forecr-DSBOARD-NX2-patches.patch
new file mode 100644
index 0000000..caf7408
--- /dev/null
+++ b/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra/0001-Port-Forecr-DSBOARD-NX2-patches.patch
@@ -0,0 +1,3502 @@
+From 19cb4b43914822a4c035ba42d884eedce787f9b2 Mon Sep 17 00:00:00 2001
+From: Alexandru Costache <alexandru@balena.io>
+Date: Thu, 19 Jan 2023 17:57:21 +0100
+Subject: [PATCH] Port Forecr DSBOARD NX2 patches
+
+These are ported from https://github.com/mistelektronik/forecr_xavier_kernel/commits/Jetpack-5.0.2
+at HEAD SHA a45beb54c1cabb4ed1ff488d6b03bee227b1ca56
+
+Upstream-status: Backport
+Signed-off-by: Alexandru Costache <alexandru@balena.io>
+---
+ drivers/net/usb/qmi_wwan.c                    |   11 +
+ drivers/tty/serial/8250/Kconfig               |    5 +
+ drivers/tty/serial/8250/Makefile              |    1 +
+ drivers/tty/serial/8250/xr17v35x.c            | 2540 +++++++++++++++++
+ drivers/usb/serial/option.c                   |   54 +-
+ .../platform/t19x/jakku/kernel-dts/Makefile   |    4 +
+ ...tegra194-p3668-dsboard-nx2-0000-imx477.dts |  211 ++
+ ...4-p3668-dsboard-nx2-0000-rev121-imx477.dts |  216 ++
+ ...tegra194-p3668-dsboard-nx2-0000-rev121.dts |  103 +
+ .../tegra194-p3668-dsboard-nx2-0000.dts       |   98 +
+ 10 files changed, 3242 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/tty/serial/8250/xr17v35x.c
+ create mode 100644 nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-imx477.dts
+ create mode 100644 nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dts
+ create mode 100644 nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-rev121.dts
+ create mode 100644 nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000.dts
+
+diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
+index 597766d14563..5fd27778f00a 100644
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -1252,6 +1252,7 @@ static const struct usb_device_id products[] = {
+ 	{QMI_FIXED_INTF(0x19d2, 0x1426, 2)},	/* ZTE MF91 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1428, 2)},	/* Telewell TW-LTE 4G v2 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1432, 3)},	/* ZTE ME3620 */
++	{QMI_FIXED_INTF(0x19d2, 0x1485, 5)},	/* ZTE MF286D */
+ 	{QMI_FIXED_INTF(0x19d2, 0x2002, 4)},	/* ZTE (Vodafone) K3765-Z */
+ 	{QMI_FIXED_INTF(0x2001, 0x7e16, 3)},	/* D-Link DWM-221 */
+ 	{QMI_FIXED_INTF(0x2001, 0x7e19, 4)},	/* D-Link DWM-221 B1 */
+@@ -1286,6 +1287,7 @@ static const struct usb_device_id products[] = {
+ 	{QMI_QUIRK_SET_DTR(0x1199, 0x907b, 8)},	/* Sierra Wireless EM74xx */
+ 	{QMI_QUIRK_SET_DTR(0x1199, 0x907b, 10)},/* Sierra Wireless EM74xx */
+ 	{QMI_QUIRK_SET_DTR(0x1199, 0x9091, 8)},	/* Sierra Wireless EM7565 */
++	{QMI_QUIRK_SET_DTR(0x1199, 0xc081, 8)},	/* Sierra Wireless EM7590 */
+ 	{QMI_FIXED_INTF(0x1bbb, 0x011e, 4)},	/* Telekom Speedstick LTE II (Alcatel One Touch L100V LTE) */
+ 	{QMI_FIXED_INTF(0x1bbb, 0x0203, 2)},	/* Alcatel L800MA */
+ 	{QMI_FIXED_INTF(0x2357, 0x0201, 4)},	/* TP-LINK HSUPA Modem MA180 */
+@@ -1293,11 +1295,15 @@ static const struct usb_device_id products[] = {
+ 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1031, 3)}, /* Telit LE910C1-EUX */
+ 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1040, 2)},	/* Telit LE922A */
+ 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1050, 2)},	/* Telit FN980 */
++	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1057, 2)},	/* Telit FN980 */
++	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1060, 2)},	/* Telit LN920 */
++	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1070, 2)},	/* Telit FN990 */
+ 	{QMI_FIXED_INTF(0x1bc7, 0x1100, 3)},	/* Telit ME910 */
+ 	{QMI_FIXED_INTF(0x1bc7, 0x1101, 3)},	/* Telit ME910 dual modem */
+ 	{QMI_FIXED_INTF(0x1bc7, 0x1200, 5)},	/* Telit LE920 */
+ 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1201, 2)},	/* Telit LE920, LE920A4 */
+ 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1230, 2)},	/* Telit LE910Cx */
++	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1250, 0)},	/* Telit LE910Cx */
+ 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1260, 2)},	/* Telit LE910Cx */
+ 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1261, 2)},	/* Telit LE910Cx */
+ 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1900, 1)},	/* Telit LN940 series */
+@@ -1320,6 +1326,7 @@ static const struct usb_device_id products[] = {
+ 	{QMI_FIXED_INTF(0x1e2d, 0x0083, 4)},	/* Cinterion PHxx,PXxx (1 RmNet + USB Audio)*/
+ 	{QMI_QUIRK_SET_DTR(0x1e2d, 0x00b0, 4)},	/* Cinterion CLS8 */
+ 	{QMI_FIXED_INTF(0x1e2d, 0x00b7, 0)},	/* Cinterion MV31 RmNet */
++	{QMI_FIXED_INTF(0x1e2d, 0x00b9, 0)},	/* Cinterion MV31 RmNet based on new baseline */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a2, 8)},	/* Dell Wireless 5806 Gobi(TM) 4G LTE Mobile Broadband Card */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a3, 8)},	/* Dell Wireless 5570 HSPA+ (42Mbps) Mobile Broadband Card */
+ 	{QMI_FIXED_INTF(0x413c, 0x81a4, 8)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
+@@ -1329,6 +1336,7 @@ static const struct usb_device_id products[] = {
+ 	{QMI_FIXED_INTF(0x413c, 0x81b3, 8)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) */
+ 	{QMI_FIXED_INTF(0x413c, 0x81b6, 8)},	/* Dell Wireless 5811e */
+ 	{QMI_FIXED_INTF(0x413c, 0x81b6, 10)},	/* Dell Wireless 5811e */
++	{QMI_FIXED_INTF(0x413c, 0x81c2, 8)},	/* Dell Wireless 5811e */
+ 	{QMI_FIXED_INTF(0x413c, 0x81cc, 8)},	/* Dell Wireless 5816e */
+ 	{QMI_FIXED_INTF(0x413c, 0x81d7, 0)},	/* Dell Wireless 5821e */
+ 	{QMI_FIXED_INTF(0x413c, 0x81d7, 1)},	/* Dell Wireless 5821e preproduction config */
+@@ -1337,12 +1345,15 @@ static const struct usb_device_id products[] = {
+ 	{QMI_FIXED_INTF(0x413c, 0x81e6, 0)},	/* Dell Wireless 5829e */
+ 	{QMI_FIXED_INTF(0x03f0, 0x4e1d, 8)},	/* HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */
+ 	{QMI_FIXED_INTF(0x03f0, 0x9d1d, 1)},	/* HP lt4120 Snapdragon X5 LTE */
++	{QMI_QUIRK_SET_DTR(0x22de, 0x9051, 2)}, /* Hucom Wireless HM-211S/K */
+ 	{QMI_FIXED_INTF(0x22de, 0x9061, 3)},	/* WeTelecom WPD-600N */
+ 	{QMI_QUIRK_SET_DTR(0x1e0e, 0x9001, 5)},	/* SIMCom 7100E, 7230E, 7600E ++ */
++	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0125, 4)},	/* Quectel EC25, EC20 R2.0  Mini PCIe */
+ 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0121, 4)},	/* Quectel EC21 Mini PCIe */
+ 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0191, 4)},	/* Quectel EG91 */
+ 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0195, 4)},	/* Quectel EG95 */
+ 	{QMI_FIXED_INTF(0x2c7c, 0x0296, 4)},	/* Quectel BG96 */
++	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0306, 4)},	/* Quectel EG06/EP06/EM06 Mini PCIe */
+ 	{QMI_QUIRK_SET_DTR(0x2cb7, 0x0104, 4)},	/* Fibocom NL678 series */
+ 	{QMI_FIXED_INTF(0x0489, 0xe0b4, 0)},	/* Foxconn T77W968 LTE */
+ 	{QMI_FIXED_INTF(0x0489, 0xe0b5, 0)},	/* Foxconn T77W968 LTE with eSIM support*/
+diff --git a/drivers/tty/serial/8250/Kconfig b/drivers/tty/serial/8250/Kconfig
+index 603137da4736..f33a556fa3e6 100644
+--- a/drivers/tty/serial/8250/Kconfig
++++ b/drivers/tty/serial/8250/Kconfig
+@@ -518,3 +518,8 @@ config SERIAL_OF_PLATFORM
+ 	  are probed through devicetree, including Open Firmware based
+ 	  PowerPC systems and embedded systems on architectures using the
+ 	  flattened device tree format.
++
++config SERIAL_8250_XR17V35X
++	tristate "XR17V35X PCIe UART IC driver"
++	help
++	  XR17V35X PCIe UART IC driver
+diff --git a/drivers/tty/serial/8250/Makefile b/drivers/tty/serial/8250/Makefile
+index a8bfb654d490..ce8e7f16ec2e 100644
+--- a/drivers/tty/serial/8250/Makefile
++++ b/drivers/tty/serial/8250/Makefile
+@@ -39,5 +39,6 @@ obj-$(CONFIG_SERIAL_8250_MID)		+= 8250_mid.o
+ obj-$(CONFIG_SERIAL_8250_PXA)		+= 8250_pxa.o
+ obj-$(CONFIG_SERIAL_8250_TEGRA)		+= 8250_tegra.o
+ obj-$(CONFIG_SERIAL_OF_PLATFORM)	+= 8250_of.o
++obj-$(CONFIG_SERIAL_8250_XR17V35X)	+= xr17v35x.o
+ 
+ CFLAGS_8250_ingenic.o += -I$(srctree)/scripts/dtc/libfdt
+diff --git a/drivers/tty/serial/8250/xr17v35x.c b/drivers/tty/serial/8250/xr17v35x.c
+new file mode 100644
+index 000000000000..16c8aabaaf45
+--- /dev/null
++++ b/drivers/tty/serial/8250/xr17v35x.c
+@@ -0,0 +1,2540 @@
++/*****************************************************************************/
++/*
++*      xr17v35x.c  -- MaxLinear multiport serial driver.
++*
++*      
++*****************************************************************************
++*                                        Copyright (c) 2010, MaxLinear, Inc.
++*****************************************************************************
++*
++*      Based on Linux 2.6.37 Kernel's  drivers/serial/8250.c and /8250_pci.c
++*
++*      This program is free software; you can redistribute it and/or modify
++*      it under the terms of the GNU General Public License as published by
++*      the Free Software Foundation; either version 2 of the License, or
++*      (at your option) any later version.
++*
++*      This program is distributed in the hope that it will be useful,
++*      but WITHOUT ANY WARRANTY; without even the implied warranty of
++*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++*      GNU General Public License for more details.
++*
++*      You should have received a copy of the GNU General Public License
++*      along with this program; if not, write to the Free Software
++*      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++*
++*
++*	   Multiport Serial Driver for MaxLinear's PCI Family of UARTs (XR17V258/254/252/358/354/352/8358/4358/8354)
++*								  (XR17D158/154/152)
++*       ChangeLog:
++*	   for    	: LINUX 2.6.32 and newer (Tested on various kernel versions from 2.6.32 to 4.15)
++*	   date   	: July 2019
++*	   version	: 2.6 
++*	 Note: XR_17v35x_UART_RHR was not defined. Fixed  
++*	Check Release Notes for information on what has changed in the new version.
++*
++*/
++
++#include <linux/module.h>
++#include <linux/tty.h>
++#include <linux/ioport.h>
++#include <linux/init.h>
++#include <linux/console.h>
++#include <linux/sysrq.h>
++#include <linux/delay.h>
++#include <linux/device.h>
++#include <linux/pci.h>
++#include <linux/sched.h>
++#include <linux/string.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++
++#include <linux/export.h>
++#include <linux/kthread.h>
++#include <linux/mutex.h>
++#include <linux/sched.h>
++
++#include <linux/file.h>
++#include <linux/fs.h>
++#include <linux/uaccess.h>
++
++#include <linux/tty_flip.h>
++#include <linux/serial_reg.h>
++#include <linux/serial.h>
++#include <linux/serial_core.h>
++
++
++
++
++#include <asm/io.h>
++#include <asm/irq.h>
++#include <asm/irq.h>
++#include <asm/bitops.h>
++#include <asm/byteorder.h>
++#include <asm/serial.h>
++#include <asm/io.h>
++#include <asm/uaccess.h>
++
++
++#include "linux/version.h"
++
++#define _INLINE_ inline
++
++#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 8, 0)
++#define __devinitdata
++#define __devinit
++#define __devexit
++#define __devexit_p
++#endif
++
++#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 8, 0)
++struct serial_uart_config {
++	char	*name;
++	int	dfl_xmit_fifo_size;
++	int	flags;
++};
++#endif
++
++//void tty_flip_buffer_push(struct tty_port *port);
++
++/*
++ * Definitions for PCI support.
++ */
++#define FL_BASE_MASK		0x0007
++#define FL_BASE0		0x0000
++#define FL_GET_BASE(x)		(x & FL_BASE_MASK)
++
++#define NR_PORTS	256
++
++#define XR_MAJOR       30
++#define XR_MINOR       0
++/*	
++   Set this parameter to 1 to enable Debug mode
++   The Driver enables the internal loopback under debug mode
++   To disable internal loopback go to serialxr_set_termios
++*/
++#ifndef DEBUG
++#define DEBUG 		0
++#endif
++
++/*
++ * The special register set for XR17V35x UARTs.
++ */
++ 
++#define XR_17v35x_UART_RHR			0 
++#define XR_17v35x_UART_THR			0
++#define	XR_17V35X_UART_DLD	        2
++#define	XR_17V35X_UART_MSR	        6
++#define XR_17V35X_EXTENDED_FCTR		8
++#define XR_17V35X_EXTENDED_EFR		9
++#define XR_17V35X_TXFIFO_CNT		10
++#define XR_17V35X_EXTENDED_TXTRG	10
++#define XR_17V35X_RXFIFO_CNT		11
++#define XR_17V35X_EXTENDED_RXTRG	11
++#define XR_17V35X_UART_XOFF2      	13 
++#define XR_17V35X_UART_XOFF1 		0xC0
++#define XR_17V35X_UART_XON1			0xE0
++#define XR_17V35X_FCTR_RTS_8DELAY	0x03
++#define XR_17V35X_FCTR_TRGD			192
++#define XR_17V35x_FCTR_RS485	    0x20
++
++#define XR_17V35x_MPIOLVL_7_0       0x90
++#define XR_17V35x_MPIO3T_7_0        0x91
++#define XR_17V35x_MPIOSEL_7_0       0x93
++#define XR_17V35x_MPIOLVL_15_8       0x96
++#define XR_17V35x_MPIO3T_15_8        0x97
++#define XR_17V35x_MPIOSEL_15_8       0x99
++
++
++// Set this parameter to 1 to enable RS485 mode
++#define ENABLE_RS485		        0
++//Set this parameter to 1 to enable DTR RS-485 half duplex direction control
++#define USE_DTR_RS485                    0
++// Set this parameter to 1 to enabled internal loopback
++#define ENABLE_INTERNAL_LOOPBACK      0
++
++#define UART_17V35X_RX_OFFSET		0x100
++#define UART_17V35X_TX_OFFSET 		0x100
++
++#define	XR_17V35X_IER_RTSDTR	        0x40
++#define XR_17V35X_IER_CTSDSR	        0x80
++
++#define XR_17V35X_8XMODE	        0x88
++#define XR_17V35X_4XMODE	        0x89
++
++#define DIVISOR_CHANGED   0
++
++#define PCI_NUM_BAR_RESOURCES	6
++#define CAPTURE_SERIAL_INDEX    1
++
++struct serial_private {
++	struct pci_dev		*dev;
++	unsigned int		nr;
++	void __iomem		*remapped_bar[PCI_NUM_BAR_RESOURCES];
++	struct pci_serial_quirk	*quirk;
++	int    uart_index[NR_PORTS];
++	int			line[0];
++};
++
++struct pciserial_board {
++	unsigned int flags;
++	unsigned int num_ports;
++	unsigned int base_baud;
++	unsigned int uart_offset;
++	unsigned int reg_shift;
++	unsigned int first_offset;
++};
++
++/*
++ * init function returns:
++ *  > 0 - number of ports
++ *  = 0 - use board->num_ports
++ *  < 0 - error
++ */
++struct pci_serial_quirk {
++	u32	vendor;
++	u32	device;
++	u32	subvendor;
++	u32	subdevice;
++	int	(*init)(struct pci_dev *dev);
++	int	(*setup)(struct serial_private *, 
++			 const struct pciserial_board *,
++			 struct uart_port *, int);
++	void	(*exit)(struct pci_dev *dev);
++};
++
++/*
++ * This is the configuration table for all of the PCI serial boards
++ * which we support.  It is directly indexed by the xrpci_board_num_t enum
++ * value, which is encoded in the pci_device_id PCI probe table's
++ * driver_data member.
++ *
++ * The makeup of these names are:
++ *  pbn_bn{_bt}_n_baud
++ *
++ *  bn   = PCI BAR number
++ *  bt   = Index using PCI BARs
++ *  n    = number of serial ports
++ *  baud = baud rate
++ */
++enum xrpci_board_num_t {
++	xr_8port = 0,
++	xr_4port,
++	xr_2port,
++	xr_4354port,
++	xr_8354port,
++	xr_4358port,
++	xr_8358port,
++	xr_258port,
++	xr_254port,
++	xr_252port,
++	xr_158port,
++	xr_154port,
++	xr_152port,
++};
++
++static struct pciserial_board xrpciserial_boards[] __devinitdata = {
++	[xr_8port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 8,
++		.base_baud	= 7812500*4,
++		.uart_offset	= 0x400,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	
++	[xr_4port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 4,
++		.base_baud	= 7812500*4,
++		.uart_offset	= 0x400,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_2port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 2,
++		.base_baud	= 7812500*4,
++		.uart_offset	= 0x400,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_4354port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 8,
++		.base_baud	= 7812500*4,
++		.uart_offset	= 0x400,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_8354port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 12,
++		.base_baud	= 7812500*4,
++		.uart_offset	= 0x400,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_4358port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 12,
++		.base_baud	= 7812500*4,
++		.uart_offset	= 0x400,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_8358port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 16,
++		.base_baud	= 7812500*4,
++		.uart_offset	= 0x400,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_258port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 8,
++		.base_baud	= 1500000,
++		.uart_offset	= 0x200,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_254port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 4,
++		.base_baud	= 1500000,
++		.uart_offset	= 0x200,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_252port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 2,
++		.base_baud	= 1500000,
++		.uart_offset	= 0x200,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++    	[xr_158port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 8,
++		.base_baud	= 921600,
++		.uart_offset	= 0x200,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_154port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 4,
++		.base_baud	= 921600,
++		.uart_offset	= 0x200,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++	[xr_152port] = {
++		.flags		= FL_BASE0,
++		.num_ports	= 2,
++		.base_baud	= 921600,
++		.uart_offset	= 0x200,
++		.reg_shift	= 0,
++		.first_offset	= 0,
++	},
++
++};
++
++/*
++ * Configuration:
++ *   share_irqs - whether we pass SA_SHIRQ to request_irq().  This option
++ *                is unsafe when used on edge-triggered interrupts.
++ */
++#define SERIALEXAR_SHARE_IRQS 1 
++unsigned int share_irqs = SERIALEXAR_SHARE_IRQS;
++
++/*
++ * Debugging.
++ */
++#if 0
++#define DEBUG_AUTOCONF(fmt...)	printk(fmt)
++#else
++#define DEBUG_AUTOCONF(fmt...)	do { } while (0)
++#endif
++
++#if DEBUG
++#define DEBUG_INTR(fmt...)	printk(fmt)
++#else
++#define DEBUG_INTR(fmt...)	do { } while (0)
++#endif
++
++#define PASS_LIMIT	256
++
++/*
++ * We default to IRQ0 for the "no irq" hack.   Some
++ * machine types want others as well - they're free
++ * to redefine this in their header file.
++ */
++#define is_real_interrupt(irq)	((irq) != 0)
++#define MSR_SAVE_FLAGS UART_MSR_ANY_DELTA
++
++#define LSR_SAVE_FLAGS UART_LSR_BRK_ERROR_BITS
++struct uart_xr_port {
++	struct uart_port	port;
++	struct timer_list	timer;		/* "no irq" timer */
++	struct list_head	list;		/* ports on this IRQ */
++	unsigned short		capabilities;	/* port capabilities */
++	unsigned short		bugs;		/* port bugs */
++	unsigned int		tx_loadsz;	/* transmit fifo load size */
++	unsigned char		acr;
++	unsigned char		ier;
++	unsigned char		lcr;
++	unsigned char		mcr;
++	unsigned char		mcr_mask;	/* mask of user bits */
++	unsigned char		mcr_force;	/* mask of forced bits */
++
++	unsigned char		lsr_saved_flags;
++	unsigned char		msr_saved_flags;
++	
++	unsigned short 		deviceid;
++	unsigned char		channelnum;
++	unsigned char       multidrop_address;
++    unsigned char       multidrop_mode;
++    unsigned char       is_match_address;
++	/*
++	 * We provide a per-port pm hook.
++	 */
++	void			(*pm)(struct uart_port *port,
++					  unsigned int state, unsigned int old);
++};
++
++struct irq_info {
++	struct			hlist_node node;
++	int			irq;
++	spinlock_t		lock;	/* Protects list not the hash */
++	struct list_head	*head;
++};
++
++#define NR_IRQ_HASH		32	/* Can be adjusted later */
++static struct hlist_head irq_lists[NR_IRQ_HASH];
++static DEFINE_MUTEX(hash_mutex);	/* Used to walk the hash */
++
++/*
++ * Here we define the default xmit fifo size used for each type of UART.
++ */
++#define PORT_MAX_XR 2 
++#define XRPCIe_TYPE 1 // the second entry that is [1] in the array
++#define XRPCI25x_TYPE 2 // the third entry that is [2] in the array
++
++static const struct serial_uart_config uart_config[PORT_MAX_XR+1] = {
++	{ "Unknown",	1,	0 },
++	{ "XR17v35x",	256,	0 },
++	{ "XR17v25x",	64,	0 },
++};
++
++static int
++setup_port(struct serial_private *priv, struct uart_port *port,
++	   int bar, int offset, int regshift)
++{
++	struct pci_dev *dev = priv->dev;
++	unsigned long base, len;
++
++	if (bar >= PCI_NUM_BAR_RESOURCES)
++		return -EINVAL;
++
++	base = pci_resource_start(dev, bar);
++
++	if (pci_resource_flags(dev, bar) & IORESOURCE_MEM) {
++		len =  pci_resource_len(dev, bar);
++
++		if (!priv->remapped_bar[bar])
++			priv->remapped_bar[bar] = ioremap(base, len);
++		if (!priv->remapped_bar[bar])
++			return -ENOMEM;
++
++		port->iotype = UPIO_MEM;
++		port->iobase = 0;
++		port->mapbase = base + offset;
++		port->membase = priv->remapped_bar[bar] + offset;
++		port->regshift = regshift;
++	} else {
++		//Exar's got to be memory mapped. some hardware reading error?
++		return -EINVAL;
++	}
++	return 0;
++}
++
++
++static int
++pci_default_setup(struct serial_private *priv,
++		  const struct pciserial_board *board,
++		  struct uart_port *port, int idx)
++{
++	unsigned int bar, offset = board->first_offset;
++
++	bar = FL_GET_BASE(board->flags);	
++	offset += idx * board->uart_offset;
++	//printk(KERN_INFO "Exar PCIe device 0x%x\n", priv->dev->device);
++	if((priv->dev->device == 0x4354 || priv->dev->device == 0x8354) && (idx >= 4))
++	{
++	    offset += 0x1000; // the ports on expansion device for 0x(4/8)354 sit at bar0+0x2000 offset. 
++			      // So we need to add 0x1000 here as 4*0x400
++	}
++
++	return setup_port(priv, port, bar, offset, board->reg_shift);
++}
++
++/*
++ * Master list of serial port init/setup/exit quirks.
++ * This does not describe the general nature of the port.
++ * (ie, baud base, number and location of ports, etc)
++ *
++ * This list is ordered alphabetically by vendor then device.
++ * Specific entries must come before more generic entries.
++ */
++static struct pci_serial_quirk pci_serial_quirks[] = {	
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x358,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++	
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x354,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x352,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x4354,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x8354,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x4358,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x8358,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x258,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++	
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x254,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x252,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++		{
++		.vendor		= 0x13a8,
++		.device		= 0x158,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++	
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x154,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++	{
++		.vendor		= 0x13a8,
++		.device		= 0x152,
++		.subvendor	= PCI_ANY_ID,
++		.subdevice	= PCI_ANY_ID,
++		.setup		= pci_default_setup,	
++	},
++
++};
++
++static inline int quirk_id_matches(u32 quirk_id, u32 dev_id)
++{
++	return quirk_id == PCI_ANY_ID || quirk_id == dev_id;
++}
++
++static struct pci_serial_quirk *find_quirk(struct pci_dev *dev)
++{
++	struct pci_serial_quirk *quirk;
++
++	for (quirk = pci_serial_quirks; ; quirk++)
++		if (quirk_id_matches(quirk->vendor, dev->vendor) &&
++		    quirk_id_matches(quirk->device, dev->device))		    
++		 	break;
++	return quirk;
++}
++
++static _INLINE_ unsigned int serial_in(struct uart_xr_port *up, int offset)
++{
++	return readb(up->port.membase + offset);
++}
++
++static _INLINE_ void
++serial_out(struct uart_xr_port *up, int offset, int value)
++{
++	writeb(value, up->port.membase + offset);
++}
++
++static void serialxr_stop_tx(struct uart_port *port)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	int lcr;
++
++	if (up->ier & UART_IER_THRI) {
++		up->ier &= ~UART_IER_THRI;
++		lcr = serial_in(up, UART_LCR);
++		if (lcr & 0x80) {			
++			printk(KERN_INFO "channelnum %d: serialxr stop tx - LCR = 0x%x", up->channelnum, lcr);
++			serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++		}
++		serial_out(up, UART_IER, up->ier);
++	}
++}
++
++static void serialxr_start_tx(struct uart_port *port)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	int lcr;
++
++	if (!(up->ier & UART_IER_THRI)) {
++		up->ier |= UART_IER_THRI;
++		lcr = serial_in(up, UART_LCR);
++		if (lcr & 0x80) {
++			printk(KERN_INFO"channelnum %d: serialxr start tx - LCR = 0x%x", up->channelnum, lcr);
++			serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++		}
++		serial_out(up, UART_IER, up->ier);
++	}
++}
++
++static void serialxr_stop_rx(struct uart_port *port)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	int lcr;
++
++	up->ier &= ~UART_IER_RLSI;
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		printk(KERN_INFO"channelnum %d: serialxr stop rx - LCR = 0x%x", up->channelnum, lcr);
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	up->port.read_status_mask &= ~UART_LSR_DR;
++	serial_out(up, UART_IER, up->ier);
++}
++
++static void serialxr_enable_ms(struct uart_port *port)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	int lcr;
++
++	up->ier |= UART_IER_MSI;
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		printk(KERN_INFO"channelnum %d: serialxr enable ms - LCR = 0x%x", up->channelnum, lcr);
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_IER, up->ier);
++}
++
++static void
++receive_chars(struct uart_xr_port *up, unsigned int *status)
++{
++#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 9, 0)	
++	struct uart_port *port = &up->port;
++#else
++	struct tty_struct *tty = up->port.state->port.tty;	
++#endif	
++	unsigned char ch[256], lsr = *status;
++	char flag;
++	int i, lcr, datasize_in_fifo, port_index;
++	unsigned char tmp;		
++	datasize_in_fifo = serial_in(up, XR_17V35X_RXFIFO_CNT);
++	while(datasize_in_fifo!=serial_in(up, XR_17V35X_RXFIFO_CNT))
++	/*Read Receive Fifo count until we get read same value twice*/
++		datasize_in_fifo=serial_in(up, XR_17V35X_RXFIFO_CNT);
++
++  	port_index = up->port.line;
++	flag = TTY_NORMAL;
++  
++	if (unlikely(lsr & (UART_LSR_BI | UART_LSR_PE | UART_LSR_FE | UART_LSR_OE))) 
++	{
++		/*
++		* Mask off conditions which should be ignored.
++		*/
++		lsr &= up->port.read_status_mask;
++        if (lsr & UART_LSR_OE) 
++		{
++			printk("OverRun Happen....");
++		} 
++		if (lsr & UART_LSR_BI) 
++		{
++			DEBUG_INTR("handling break....");
++			flag = TTY_BREAK;
++		} 
++		else if (lsr & UART_LSR_PE)
++		{
++			flag = TTY_PARITY;
++			
++			if(up->multidrop_mode == 1)
++			{
++				  //memcpy_fromio(ch, up->port.membase + UART_17V35X_RX_OFFSET, datasize_in_fifo);
++					for(i=0;i<datasize_in_fifo;i++)
++					{
++						lcr = serial_in(up, UART_LCR);
++						if (lcr & 0x80) {
++							printk(KERN_INFO"channelnum %d: receive chars (multidrop mode) - LCR = 0x%x", up->channelnum, lcr);
++							serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++						}
++					  ch[i]= serial_in(up, XR_17v35x_UART_RHR);
++					}
++					up->port.icount.rx+=datasize_in_fifo;
++		          //up->port.icount.rx+=datasize_in_fifo;
++				  DEBUG_INTR("Receive address byte:%02x\n",ch[0]);
++				  if(up->is_match_address == 0)
++				  {
++     				  if(ch[0] == up->multidrop_address)
++     				  {
++     				    DEBUG_INTR(" Enable the receiver\n");
++     					//set EFR[4] = 1; enable the shaded bits 
++     				    tmp = serial_in(up, XR_17V35X_EXTENDED_EFR);
++     				    tmp |=0x10;
++     				    serial_out(up, XR_17V35X_EXTENDED_EFR, tmp);
++     				    serial_out(up,XR_17V35X_UART_MSR, 0);//Enable the receiver 
++     				    //set EFR[4] = 0; disable the shaded bits 
++     				    tmp = serial_in(up, XR_17V35X_EXTENDED_EFR);
++     				    tmp &=~0x10;
++     				    serial_out(up, XR_17V35X_EXTENDED_EFR, tmp); 
++						up->is_match_address = 1;
++     				  }
++					  else
++					  {
++					    //do nothing
++					  }
++				  }
++				  else
++				  {
++     				  if(ch[0] == up->multidrop_address)
++     				  {
++     				    //do dothing
++     				  }
++					  else
++     				  {
++     				    DEBUG_INTR(" Disable the receiver\n");
++     					//set EFR[4] = 1; enable the shaded bits 
++     				    tmp = serial_in(up, XR_17V35X_EXTENDED_EFR);
++     				    tmp |=0x10;
++     				    serial_out(up, XR_17V35X_EXTENDED_EFR, tmp);
++     				    serial_out(up,XR_17V35X_UART_MSR, 0x04);//Disable the receiver 
++     				     //set EFR[4] = 0; disable the shaded bits 
++     				    tmp = serial_in(up, XR_17V35X_EXTENDED_EFR);
++     				    tmp &=~0x10;
++     				    serial_out(up, XR_17V35X_EXTENDED_EFR, tmp);
++						up->is_match_address = 0;
++     				  }
++				  }
++				  return;
++			}
++			if(up->multidrop_mode == 0)
++			{
++			    printk("handling port<%d> Parity error....(%d)\n",port_index,up->multidrop_mode);
++			}
++			
++		}
++		else if (lsr & UART_LSR_FE)
++		{
++		    DEBUG_INTR("handling Frame error....\n");	
++			flag = TTY_FRAME;
++		}
++	}
++	
++    //memcpy_fromio(ch, up->port.membase + UART_17V35X_RX_OFFSET, datasize_in_fifo);
++			
++	//print_hex_dump(KERN_DEBUG,"R:",DUMP_PREFIX_NONE,16,1,ch,datasize_in_fifo,1);
++    for(i=0;i<datasize_in_fifo;i++)
++    {
++		lcr = serial_in(up, UART_LCR);
++		if (lcr & 0x80) {
++			printk(KERN_INFO"channelnum %d: receive chars - LCR = 0x%x", up->channelnum, lcr);
++			serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++		}
++      ch[i]= serial_in(up, XR_17v35x_UART_RHR);
++    }
++	up->port.icount.rx+=datasize_in_fifo;
++	
++	for(i = 0; i < datasize_in_fifo; i++)
++	{
++		if (uart_handle_sysrq_char(&up->port, ch[i]))
++			continue;
++		uart_insert_char(&up->port, lsr, UART_LSR_OE, ch[i], flag);
++	}
++    spin_unlock(&up->port.lock);
++#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 9, 0)
++	tty_flip_buffer_push(&port->state->port);
++#else
++	tty_flip_buffer_push(tty);
++#endif
++	spin_lock(&up->port.lock);
++
++	DEBUG_INTR(" LSR_DR...");
++}
++
++static void transmit_chars(struct uart_xr_port *up)
++{
++	struct circ_buf *xmit = &up->port.state->xmit;
++	int count, bytes_in_fifo, tmp;
++	int i, lcr;
++	unsigned char *ch;
++	if (up->port.x_char) {
++		serial_out(up, UART_TX, up->port.x_char);
++		up->port.icount.tx++;
++		up->port.x_char = 0;
++		return;
++	}
++	if (uart_tx_stopped(&up->port)) {
++		serialxr_stop_tx(&up->port);
++		return;
++	}
++	if (uart_circ_empty(xmit)) {
++		serialxr_stop_tx(&up->port);
++		return;
++	}
++
++	bytes_in_fifo = serial_in(up, XR_17V35X_TXFIFO_CNT);
++	// read the fifo count untill we get the same value twice
++	while (bytes_in_fifo != serial_in(up, XR_17V35X_TXFIFO_CNT))
++		bytes_in_fifo = serial_in(up, XR_17V35X_TXFIFO_CNT);
++
++	// how much buffer is availabe now to write?	
++	count = up->port.fifosize - bytes_in_fifo;
++	
++	if (uart_circ_chars_pending(xmit) < count)
++		count = uart_circ_chars_pending(xmit);
++		
++	do
++	{	
++		// if the count is more than (tail to end of the buffer), transmit only the rest here.
++		// tail+tmp&(UART_XMIT_SIZE-1) will reset the tail to the starting of the circular buffer
++		if( ((xmit->tail + count) & (UART_XMIT_SIZE-1)) < xmit->tail)
++		{			
++			tmp = UART_XMIT_SIZE - xmit->tail;
++			//memcpy_toio(up->port.membase + UART_17V35X_TX_OFFSET, &(xmit->buf[xmit->tail]), tmp);
++			ch = (unsigned char *)&(xmit->buf[xmit->tail]);
++			//print_hex_dump(KERN_DEBUG,"T:",DUMP_PREFIX_NONE,16,1,&(xmit->buf[xmit->tail]),tmp,1);
++			for(i=0;i<tmp;i++)
++			{
++				lcr = serial_in(up, UART_LCR);
++				if (lcr & 0x80) {
++					printk(KERN_INFO"channelnum %d: transmit_chars1 - LCR = 0x%x", up->channelnum, lcr);
++					serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++				}				
++			  serial_out(up, XR_17v35x_UART_THR, ch[i]);
++			}
++			xmit->tail += tmp;
++			xmit->tail &= (UART_XMIT_SIZE-1);
++			up->port.icount.tx += tmp;
++			count	-= tmp;
++		}
++		else
++		{	
++		    ch = (unsigned char *)&(xmit->buf[xmit->tail]);
++			//memcpy_toio(up->port.membase + UART_17V35X_TX_OFFSET, &(xmit->buf[xmit->tail]), count);	
++			for(i=0;i < count;i++)
++			{
++				lcr = serial_in(up, UART_LCR);
++				if (lcr & 0x80) {
++					printk(KERN_INFO"channelnum %d: transmit_chars2 - LCR = 0x%x", up->channelnum, lcr);
++					serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++				}
++			  serial_out(up, XR_17v35x_UART_THR, ch[i]);
++			}				    
++			xmit->tail += count;
++			xmit->tail &= UART_XMIT_SIZE - 1;
++			up->port.icount.tx += count;
++			count = 0;
++		}
++
++	}while (count > 0);
++   	
++	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
++		uart_write_wakeup(&up->port);
++
++	DEBUG_INTR("THRE...");
++
++	if (uart_circ_empty(xmit))
++		serialxr_stop_tx(&up->port);
++}
++
++static unsigned int check_modem_status(struct uart_xr_port *up)
++{
++	unsigned int status = serial_in(up, UART_MSR);
++
++	status |= up->msr_saved_flags;
++	up->msr_saved_flags = 0;
++	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
++	    up->port.state != NULL) {
++		if (status & UART_MSR_TERI)
++			up->port.icount.rng++;
++		if (status & UART_MSR_DDSR)
++			up->port.icount.dsr++;
++		if (status & UART_MSR_DDCD)
++			uart_handle_dcd_change(&up->port, status & UART_MSR_DCD);
++		if (status & UART_MSR_DCTS)
++			uart_handle_cts_change(&up->port, status & UART_MSR_CTS);
++
++		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
++	}
++
++	return status;
++}
++
++/*
++ * This handles the interrupt from one port.
++ */
++static void serialxr_handle_port(struct uart_xr_port *up)
++{
++	unsigned int status;
++	unsigned long flags;
++
++	spin_lock_irqsave(&up->port.lock, flags);
++
++	status = serial_in(up, UART_LSR);
++
++	DEBUG_INTR("status = %x...", status);
++
++	if (status & (UART_LSR_DR | UART_LSR_BI))
++		receive_chars(up, &status);
++	check_modem_status(up);
++	if (status & UART_LSR_THRE)
++		transmit_chars(up);
++
++	spin_unlock_irqrestore(&up->port.lock, flags);
++}
++
++/*
++ * This is the serial driver's interrupt routine.
++ *
++ * Arjan thinks the old way was overly complex, so it got simplified.
++ * Alan disagrees, saying that need the complexity to handle the weird
++ * nature of ISA shared interrupts.  (This is a special exception.)
++ *
++ * In order to handle ISA shared interrupts properly, we need to check
++ * that all ports have been serviced, and therefore the ISA interrupt
++ * line has been de-asserted.
++ *
++ * This means we need to loop through all ports. checking that they
++ * don't have an interrupt pending.
++ */
++static irqreturn_t serialxr_interrupt(int irq, void *dev_id)
++{
++	struct irq_info *i = dev_id;
++	struct list_head *l, *end = NULL;
++	int pass_counter = 0, handled = 0;
++
++	DEBUG_INTR("serialxr_interrupt(%d)...", irq);
++
++	spin_lock(&i->lock);
++
++	l = i->head;
++	do {
++		struct uart_xr_port *up;
++		unsigned int iir, lcr;
++
++		up = list_entry(l, struct uart_xr_port, list);
++
++		lcr = serial_in(up, UART_LCR);  // store value of LCR
++		if (lcr & 0x80) {
++			printk(KERN_INFO"channelnum %d: serialxr interrupt - LCR = 0x%x", up->channelnum, lcr);
++			serial_out(up, UART_LCR, lcr & 0x7F); // ensure LCR bit-7=0 before reading UART_IIR
++		}		
++		iir = serial_in(up, UART_IIR);
++		if (!(iir & UART_IIR_NO_INT)) {
++			serialxr_handle_port(up);
++
++			handled = 1;
++
++			end = NULL;
++		} else if (end == NULL)
++			end = l;
++
++		serial_out(up, UART_LCR, lcr); // restore LCR
++		l = l->next;
++                /* add INT0 clear */
++                 serial_in(up,0x80);
++		if (l == i->head && pass_counter++ > 256) {
++			/* If we hit this, we're dead. */
++			printk(KERN_ERR "serialxr: too much work for "
++				"irq%d\n", irq);
++			break;
++		}
++	} while (l != end);
++
++	spin_unlock(&i->lock);
++
++	DEBUG_INTR("end.\n");
++	return IRQ_RETVAL(handled);
++}
++
++/*
++ * To support ISA shared interrupts, we need to have one interrupt
++ * handler that ensures that the IRQ line has been deasserted
++ * before returning.  Failing to do this will result in the IRQ
++ * line being stuck active, and, since ISA irqs are edge triggered,
++ * no more IRQs will be seen.
++ */
++static void serial_do_unlink(struct irq_info *i, struct uart_xr_port *up)
++{
++	spin_lock_irq(&i->lock);
++
++	if (!list_empty(i->head)) {
++		if (i->head == &up->list)
++			i->head = i->head->next;
++		list_del(&up->list);
++	} else {
++		BUG_ON(i->head != &up->list);
++		i->head = NULL;
++	}
++
++	spin_unlock_irq(&i->lock);
++
++	/* List empty so throw away the hash node */
++	if (i->head == NULL) {
++		hlist_del(&i->node);
++		kfree(i);
++	}
++}
++
++static int serial_link_irq_chain(struct uart_xr_port *up)
++{
++	struct hlist_head *h;
++	struct hlist_node *n;
++	struct irq_info *i;
++	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
++
++	mutex_lock(&hash_mutex);
++
++	h = &irq_lists[up->port.irq % NR_IRQ_HASH];
++
++	hlist_for_each(n, h) {
++		i = hlist_entry(n, struct irq_info, node);
++		if (i->irq == up->port.irq)
++			break;
++	}
++
++	if (n == NULL) {
++		i = kzalloc(sizeof(struct irq_info), GFP_KERNEL);
++		if (i == NULL) {
++			mutex_unlock(&hash_mutex);
++			return -ENOMEM;
++		}
++		spin_lock_init(&i->lock);
++		i->irq = up->port.irq;
++		hlist_add_head(&i->node, h);
++	}
++	mutex_unlock(&hash_mutex);
++
++	spin_lock_irq(&i->lock);
++
++	if (i->head) {
++		list_add_tail(&up->list, i->head);
++		spin_unlock_irq(&i->lock);
++
++		ret = 0;
++	} else {
++		INIT_LIST_HEAD(&up->list);
++		i->head = &up->list;
++		spin_unlock_irq(&i->lock);
++		irq_flags |= up->port.irqflags;
++		ret = request_irq(up->port.irq, serialxr_interrupt,
++				  irq_flags, "xrserial", i);
++		if (ret < 0)
++			serial_do_unlink(i, up);
++	}
++
++	return ret;
++}
++
++static void serial_unlink_irq_chain(struct uart_xr_port *up)
++{
++	struct irq_info *i;
++	struct hlist_node *n;
++	struct hlist_head *h;
++
++	mutex_lock(&hash_mutex);
++
++	h = &irq_lists[up->port.irq % NR_IRQ_HASH];
++
++	hlist_for_each(n, h) {
++		i = hlist_entry(n, struct irq_info, node);
++		if (i->irq == up->port.irq)
++			break;
++	}
++
++	BUG_ON(n == NULL);
++	BUG_ON(i->head == NULL);
++
++	if (list_empty(i->head))
++		free_irq(up->port.irq, i);
++
++	serial_do_unlink(i, up);
++	mutex_unlock(&hash_mutex);
++}
++
++static inline int poll_timeout(int timeout)
++{
++	return timeout > 6 ? (timeout / 2 - 2) : 1;
++}
++
++/*
++ * This function is used to handle ports that do not have an
++ * interrupt.  This doesn't work very well for 16450's, but gives
++ * barely passable results for a 16550A.  (Although at the expense
++ * of much CPU overhead).
++ */
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
++static void serialxr_timeout(struct timer_list *p_tl)
++#else
++static void serialxr_timeout(unsigned long data)
++#endif
++{
++	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
++	struct uart_xr_port *up = from_timer(up, p_tl, timer);
++	#else
++	struct uart_xr_port *up = (struct uart_xr_port *)data;
++	#endif
++
++	unsigned int iir;
++	int lcr;
++
++	lcr = serial_in(up, UART_LCR);  // check value of LCR
++	if (lcr & 0x80) {
++		serial_out(up, UART_LCR, lcr & 0x7F);	// ensure LCR bit-7=0 before reading UART_IIR
++	}
++	iir = serial_in(up, UART_IIR);
++	if (!(iir & UART_IIR_NO_INT))
++		serialxr_handle_port(up);
++	mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
++}
++
++#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
++
++static unsigned int serialxr_tx_empty(struct uart_port *port)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	unsigned long flags;
++	unsigned int lsr;
++
++	spin_lock_irqsave(&up->port.lock, flags);
++	lsr = serial_in(up, UART_LSR);
++	up->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;
++	spin_unlock_irqrestore(&up->port.lock, flags);
++
++	return (lsr & BOTH_EMPTY) == BOTH_EMPTY ? TIOCSER_TEMT : 0;
++}
++
++static unsigned int serialxr_get_mctrl(struct uart_port *port)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	unsigned int status;
++	unsigned int ret;
++
++	status = check_modem_status(up);
++
++	ret = 0;
++	if (status & UART_MSR_DCD)
++		ret |= TIOCM_CAR;
++	if (status & UART_MSR_RI)
++		ret |= TIOCM_RNG;
++	if (status & UART_MSR_DSR)
++		ret |= TIOCM_DSR;
++	if (status & UART_MSR_CTS)
++		ret |= TIOCM_CTS;
++	return ret;
++}
++
++static void serialxr_set_mctrl(struct uart_port *port, unsigned int mctrl)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	unsigned char mcr = 0, efr;
++
++	if (mctrl & TIOCM_RTS)
++		mcr |= UART_MCR_RTS;
++	if (mctrl & TIOCM_DTR)
++		mcr |= UART_MCR_DTR;
++	if (mctrl & TIOCM_OUT1)
++		mcr |= UART_MCR_OUT1;
++	if (mctrl & TIOCM_OUT2)
++		mcr |= UART_MCR_OUT2;
++	if (mctrl & TIOCM_LOOP)
++		mcr |= UART_MCR_LOOP;
++
++	mcr = (mcr & up->mcr_mask) | up->mcr_force | up->mcr;
++	
++	efr = serial_in(up, UART_EFR); 
++	efr = efr & 0xEF;	// clear access to shaded registers so that write to MCR does not change from using DTR to RTS for RS-485 control
++#if   USE_DTR_RS485
++       mcr |= 0x04;
++	printk(KERN_INFO "serialxr_set_mctrl mcr=%02x\n",mcr);
++#endif
++	serial_out(up, UART_EFR, efr);
++	serial_out(up, UART_MCR, mcr);
++}
++
++static void serialxr_break_ctl(struct uart_port *port, int break_state)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	unsigned long flags;
++
++	spin_lock_irqsave(&up->port.lock, flags);
++	if (break_state == -1)
++		up->lcr |= UART_LCR_SBC;
++	else
++		up->lcr &= ~UART_LCR_SBC;
++	serial_out(up, UART_LCR, up->lcr);
++	spin_unlock_irqrestore(&up->port.lock, flags);
++}
++
++static int serialxr_startup(struct uart_port *port)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	unsigned long flags;
++	unsigned int fctr_reg=0;
++	int retval, lcr;
++		
++	up->capabilities = uart_config[up->port.type].flags;
++ 	serial_out(up, XR_17V35X_EXTENDED_EFR, UART_EFR_ECB);
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_IER, 0);
++
++	/* Set the RX/TX trigger levels */
++	/* These are some default values, the OEMs can change these values
++		* according to their best case scenarios */
++	
++	if(up->deviceid > 0x258) // PCIe device
++	{
++		serial_out(up, XR_17V35X_EXTENDED_RXTRG, 32);
++		serial_out(up, XR_17V35X_EXTENDED_TXTRG, 64);
++	}
++	else // for 25x
++	{
++		serial_out(up, XR_17V35X_EXTENDED_RXTRG, 32); // 25x
++		serial_out(up, XR_17V35X_EXTENDED_TXTRG, 32);
++	}
++
++	/* Hysteresis level of 8, Enable Auto RS-485 Mode */
++	fctr_reg=serial_in(up,XR_17V35X_EXTENDED_FCTR);
++	DEBUG_INTR(KERN_INFO "serialxr_startup: FCTR=0x%x",fctr_reg);
++#if ENABLE_RS485
++	serial_out(up, XR_17V35X_EXTENDED_FCTR, fctr_reg|XR_17V35X_FCTR_TRGD | XR_17V35X_FCTR_RTS_8DELAY | XR_17V35x_FCTR_RS485);
++#if USE_DTR_RS485	
++	serial_out(up, UART_MCR, 0x04);  //use DTR for Auto RS-485 Control
++#endif	
++#else
++	serial_out(up, XR_17V35X_EXTENDED_FCTR, (fctr_reg|XR_17V35X_FCTR_TRGD | XR_17V35X_FCTR_RTS_8DELAY)&0xDF);
++#endif
++	
++
++	serial_out(up, UART_LCR, 0);
++
++	/* Wake up and initialize UART */
++	serial_out(up, XR_17V35X_EXTENDED_EFR, UART_EFR_ECB | 0x10/*Enable Shaded bits access*/);
++	serial_out(up,XR_17V35X_UART_MSR, 0);
++	serial_out(up, UART_LCR, 0);	// Do LCR first to avoid LCR bit-7=1 before writing to IER
++	serial_out(up, UART_IER, 0);
++
++	/*
++	 * Clear the FIFO buffers and disable them.
++	 * (they will be reeanbled in set_termios())
++	 */
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |
++			UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_FCR, 0);
++	
++	/*
++	 * Clear the interrupt registers.
++	 */
++	(void) serial_in(up, UART_LSR);
++	(void) serial_in(up, UART_RX);
++	(void) serial_in(up, UART_IIR);
++	(void) serial_in(up, UART_MSR);
++          /* add INT0 clear */
++        serial_in(up,0x80);
++if(port->irq) {
++	retval = serial_link_irq_chain(up);
++	if(retval)
++		return retval;
++}
++
++	/*
++	 * Now, initialize the UART
++	 */
++	serial_out(up, UART_LCR, UART_LCR_WLEN8);
++
++	spin_lock_irqsave(&up->port.lock, flags);
++		
++	/*
++	* Most PC uarts need OUT2 raised to enable interrupts.
++	*/
++	if (is_real_interrupt(up->port.irq))
++		up->port.mctrl |= TIOCM_OUT2;
++	//to enable intenal loop, uncomment the line below
++	//up->port.mctrl |= TIOCM_LOOP;
++
++	serialxr_set_mctrl(&up->port, up->port.mctrl);
++	spin_unlock_irqrestore(&up->port.lock, flags);
++
++	/*
++	 * Finally, enable interrupts.  Note: Modem status interrupts
++	 * are set via set_termios(), which will be occurring imminently
++	 * anyway, so we don't enable them here.
++	 */
++	up->ier = UART_IER_RLSI | UART_IER_RDI;
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		printk(KERN_INFO"channelnum %d: serialxr startup - LCR = 0x%x", up->channelnum, lcr);
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_IER, up->ier);
++
++	/*
++	 * And clear the interrupt registers again for luck.
++	 */
++	(void) serial_in(up, UART_LSR);
++	(void) serial_in(up, UART_RX);
++	(void) serial_in(up, UART_IIR);
++	(void) serial_in(up, UART_MSR);
++         /* add INT0 clear */
++        serial_in(up,0x80); 
++	return 0;
++}
++
++static void serialxr_shutdown(struct uart_port *port)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	unsigned long flags;
++	unsigned char lsr;
++	int i = 0;
++	int lcr;
++	
++	while(1)
++	{
++	   i++;
++	   lsr = serial_in(up, UART_LSR);
++	   if((lsr&0x60) != 0x60)
++	      printk("serialxr_shutdown wait TXFIFO Empty %02x",lsr);
++	   else
++	   	  break;
++	   msleep(1);
++	   if(i>1000) break;
++	   
++	}  
++	
++	/*
++	 * Disable interrupts from this port
++	 */
++	up->ier = 0;
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		printk(KERN_INFO"channelnum %d: serialxr_shutdown1 - LCR = 0x%x",	up->channelnum, lcr);
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_IER, 0);
++
++	spin_lock_irqsave(&up->port.lock, flags);
++	
++	up->port.mctrl &= ~TIOCM_OUT2;
++
++	serialxr_set_mctrl(&up->port, up->port.mctrl);
++	spin_unlock_irqrestore(&up->port.lock, flags);
++
++	/*
++	 * Disable break condition and FIFOs
++	 */
++	serial_out(up, UART_LCR, serial_in(up, UART_LCR) & (~UART_LCR_SBC) & 0x7f);
++	serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |
++				  UART_FCR_CLEAR_RCVR |
++				  UART_FCR_CLEAR_XMIT);
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		printk(KERN_INFO"channelnum %d: serialxr_shutdown2 - LCR = 0x%x",	up->channelnum, lcr);
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_FCR, 0);
++
++	/*
++	 * Read data port to reset things, and then unlink from
++	 * the IRQ chain.
++	 */
++	(void) serial_in(up, UART_RX);
++#if 1
++if (port->irq)
++	serial_unlink_irq_chain(up);
++#endif
++}
++
++static int quot_coeff = 16 ;
++static unsigned char low_baudrate_mode = 0;
++static unsigned int uart_get_divisor_exar(struct uart_port *port, unsigned int baud)
++{
++	unsigned int quot;
++
++	/*
++	 * Old custom speed handling.
++	 */
++	if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)
++		quot = port->custom_divisor;
++	else
++		{
++			if(low_baudrate_mode)
++			   quot = DIV_ROUND_CLOSEST(port->uartclk/4, quot_coeff * baud);
++			else
++			   quot = DIV_ROUND_CLOSEST(port->uartclk, quot_coeff * baud);	
++		}
++	
++	
++
++//	DEBUG_INTR(KERN_INFO "uart_get_divisor_exar:UartClk=%d QuotCoeff=0x%x",port->uartclk,quot_coeff);
++	return quot;
++}
++
++
++static unsigned int serialxr_get_divisor(struct uart_port *port, unsigned int baud)
++{
++	unsigned int quot;
++
++	quot = uart_get_divisor_exar(port, baud);
++
++	return quot;
++}
++
++static void
++serialxr_set_special_baudrate(struct uart_port *port,unsigned int special_baudrate)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	signed int baud, quot;
++    signed int quot_fraction = 0;
++	unsigned char val_4xmode;
++	unsigned char val_8xmode;
++	unsigned char lcr_bak;
++	unsigned int reg_read;
++	int port_index = up->channelnum;
++	printk(KERN_INFO "Enter in serialxr_set non-standard baudrate:%d channelnum:%d\n",special_baudrate,up->channelnum);
++	
++	baud = special_baudrate/*uart_get_baud_rate(port, termios, old, 0, port->uartclk/4)*/;
++    lcr_bak = serial_in(up, UART_LCR);
++	val_4xmode = serial_in(up, XR_17V35X_4XMODE);
++	val_8xmode = serial_in(up, XR_17V35X_8XMODE);
++	    	
++	if((port_index > 15)||(port_index < 0))
++	{
++	   return;
++	}
++
++	switch(up->deviceid)
++	{
++	  case 0x4354:
++	  case 0x8354:
++	  	if(port_index >= 4) port_index = port_index - 4;
++	  	break;
++	  case 0x4358:
++	  case 0x8358:
++	  	if(port_index >= 8) port_index = port_index - 8;
++	  	break;
++	 default:
++	 	//Do nothing
++	 	break;
++	}
++	
++		
++	if(baud < 12500000/16)
++	{//using the 16x mode
++	      val_4xmode &=~(1 << port_index);
++	      val_8xmode &=~(1 << port_index);	
++	      quot_coeff = 16;
++	      printk(KERN_INFO "Using the 16x Mode\n");
++	}
++	else if((baud >= 12500000/16)&&(baud < 12500000/4))
++	{//using the 8x mode
++	      val_4xmode &=~(1 << port_index);
++		  val_8xmode |=(1 << port_index);
++		  quot_coeff = 8;
++		  printk(KERN_INFO "Using the 8x Mode\n");
++	}
++	else 
++	{//using the 4x mode
++	   val_4xmode |=(1 << port_index);
++	   val_8xmode &=~(1 << port_index);
++	   quot_coeff = 4;
++	   printk(KERN_INFO "Using the 4x Mode\n");
++	}
++
++	serial_out(up, XR_17V35X_8XMODE, val_8xmode);
++	serial_out(up, XR_17V35X_4XMODE, val_4xmode);
++	
++	quot = serialxr_get_divisor(port, baud);
++	if(!((up->deviceid == 0x152)||(up->deviceid == 0x154)||(up->deviceid == 0x158)))
++	{
++	    unsigned int quot_16;
++	    DEBUG_INTR(KERN_INFO "XR_17V35X uartclk:%d Quot=0x%x\n",port->uartclk,quot);
++	    if(quot_coeff == 16)
++	    {
++	        quot_16 = DIV_ROUND_CLOSEST(port->uartclk, baud);
++		 quot_fraction = quot_16 & 0x0f;	
++		 quot = (quot_16 >>4);
++		
++	    }
++	    else if(quot_coeff == 8)
++	    {
++	         quot_16 = DIV_ROUND_CLOSEST(port->uartclk*2, baud);
++		  quot_fraction = quot_16 & 0x0f;	
++		  quot = (quot_16 >>4);
++	    }
++	    else if(quot_coeff == 4)
++	    {
++	         quot_16 = DIV_ROUND_CLOSEST(port->uartclk*4, baud);
++		  quot_fraction = quot_16 & 0x0f;	
++		  quot = (quot_16 >>4);
++	    }
++	    else
++	    {
++	       
++	    }
++       }
++    serial_out(up, UART_LCR, lcr_bak | UART_LCR_DLAB);/* set DLAB */
++    serial_out(up, UART_DLL, quot & 0xff);		/* LS of divisor */
++    serial_out(up, UART_DLM, quot >> 8);		/* MS of divisor */
++	//Fractional baud rate support
++	if((up->deviceid == 0x152)||(up->deviceid == 0x154)||(up->deviceid == 0x158))
++	{
++	   //nothing to do , because these devices do not have support for the DLD register.
++	}
++	else
++	{
++	    reg_read=(serial_in(up, XR_17V35X_UART_DLD)&0xF0);
++	    DEBUG_INTR(KERN_INFO "serialxr_set_special_baudrate: quot =0x%x quot_fraction=0x%x DLD_reg=0x%x\n",quot,quot_fraction,reg_read);		
++	    serial_out(up, XR_17V35X_UART_DLD, quot_fraction | reg_read);
++	    reg_read=serial_in(up, XR_17V35X_UART_DLD);
++	 }
++	 serial_out(up, UART_LCR, lcr_bak);		/* reset DLAB */
++
++}
++
++static void
++serialxr_set_termios(struct uart_port *port, struct ktermios *termios,
++		       struct ktermios *old)
++{
++struct uart_xr_port *up = (struct uart_xr_port *)port;
++unsigned char cval;
++unsigned long flags;
++signed int baud, quot;
++signed int quot_fraction = 0;
++unsigned char val_4xmode;
++unsigned char val_8xmode;
++unsigned int reg_read;
++unsigned char efr,mcr;
++int lcr;
++
++int port_index = up->channelnum;
++switch (termios->c_cflag & CSIZE) 
++{
++case CS5:
++		cval = 0x00;
++		break;
++case CS6:
++		cval = 0x01;
++		break;
++case CS7:
++		cval = 0x02;
++		break;
++default:
++case CS8:
++		cval = 0x03;
++		break;
++}
++
++if (termios->c_cflag & CSTOPB)
++		cval |= 0x04;
++if (termios->c_cflag & PARENB)
++		cval |= UART_LCR_PARITY;
++if (!(termios->c_cflag & PARODD))
++		cval |= UART_LCR_EPAR;
++#ifdef CMSPAR
++	if (termios->c_cflag & CMSPAR)
++		cval |= UART_LCR_SPAR;
++#endif
++
++	/*
++	 * Ask the core to calculate the divisor for us.
++	 */
++baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/4);
++
++printk(KERN_INFO "\nserialxr_set_termios: Port Index:%d c_ispeed:%d c_ospeed:%d baud=%d",port_index,termios->c_ispeed,termios->c_ospeed,baud);
++
++val_4xmode = serial_in(up, XR_17V35X_4XMODE);
++val_8xmode = serial_in(up, XR_17V35X_8XMODE);
++    	
++if((port_index > 15)||(port_index < 0))
++{
++   return;
++}
++
++switch(up->deviceid)
++{
++  case 0x4354:
++  case 0x8354:
++	if(port_index >= 4) port_index = port_index - 4;
++	break;
++  case 0x4358:
++  case 0x8358:
++	if(port_index >= 8) port_index = port_index - 8;
++	break;
++ default:
++	//Do nothing
++	break;
++}
++
++
++if(baud < 120)
++{
++   //set EFR[4] = 1; enable the shaded bits 
++   efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++   serial_out(up, XR_17V35X_EXTENDED_EFR, efr | 0x10);
++   mcr=serial_in(up, UART_MCR);
++   serial_out(up, UART_MCR, mcr | 0x80 );//set the prescaler (MCR bit-7 = 1, requires EFR bit-4 = 1) to divide the clock by 4.  
++   //Restore the EFR Value
++   serial_out(up, XR_17V35X_EXTENDED_EFR, efr);
++   low_baudrate_mode = 1;
++}
++else
++{
++   //set EFR[4] = 1; enable the shaded bits 
++   efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++   serial_out(up, XR_17V35X_EXTENDED_EFR, efr | 0x10);
++   mcr=serial_in(up, UART_MCR);
++   serial_out(up, UART_MCR, mcr & 0x7f );//clr the prescaler (MCR bit-7 = 1, requires EFR bit-4 = 1) to divide the clock by 1.  
++   //Restore the EFR Value
++   serial_out(up, XR_17V35X_EXTENDED_EFR, efr);
++   low_baudrate_mode = 0;
++}
++
++	
++if(baud < 12500000/16)
++{//using the 16x mode
++      val_4xmode &=~(1 << port_index);
++      val_8xmode &=~(1 << port_index);	
++      quot_coeff = 16;
++      printk(KERN_INFO "Using the 16x Mode\n");
++}
++else if((baud >= 12500000/16)&&(baud < 12500000/4))
++{//using the 8x mode
++      val_4xmode &=~(1 << port_index);
++	  val_8xmode |=(1 << port_index);
++	  quot_coeff = 8;
++	  printk(KERN_INFO "Using the 8x Mode\n");
++}
++else 
++{//using the 4x mode
++   val_4xmode |=(1 << port_index);
++   val_8xmode &=~(1 << port_index);
++   quot_coeff = 4;
++   printk(KERN_INFO "Using the 4x Mode\n");
++}
++serial_out(up, XR_17V35X_8XMODE, val_8xmode);
++serial_out(up, XR_17V35X_4XMODE, val_4xmode);
++DEBUG_INTR(KERN_INFO "XR_17V35X_4XMODE:%d \n",serial_in(up, XR_17V35X_4XMODE));
++DEBUG_INTR(KERN_INFO "XR_17V35X_8XMODE:%d \n",serial_in(up, XR_17V35X_8XMODE));
++	
++	quot = serialxr_get_divisor(port, baud);
++	if(!((up->deviceid == 0x152)||(up->deviceid == 0x154)||(up->deviceid == 0x158)))
++	 {
++	    DEBUG_INTR(KERN_INFO "XR_17V35X uartclk:%d Quot=0x%x\n",port->uartclk,quot);
++	    //#ifdef DIVISOR_CHANGED
++	    if((port->uartclk/baud) > (quot_coeff*quot))
++	    {	
++		if(quot_coeff==16)  quot_fraction = ( (port->uartclk/baud) - (quot_coeff*quot));
++		else if(quot_coeff==8) quot_fraction = ( (port->uartclk/baud) - (quot_coeff*quot))*2;
++		else if(quot_coeff==4) quot_fraction = ( (port->uartclk/baud) - (quot_coeff*quot))*4;
++	    }
++	    else if(quot > 1)
++	    {	
++	       quot--;
++	       if(quot_coeff==16)  quot_fraction = ( (port->uartclk/baud) - (quot_coeff*quot));
++	       else if(quot_coeff==8) quot_fraction = ( (port->uartclk/baud) - (quot_coeff*quot))*2;
++	       else if(quot_coeff==4) quot_fraction = ( (port->uartclk/baud) - (quot_coeff*quot))*4;
++
++	    }
++	    else
++	    {
++		quot_fraction = 0;
++	    }
++
++	    if(quot_fraction>=0x10) quot_fraction=0x0f;
++	 }
++//#endif	
++	/*
++	 * Ok, we're now changing the port state.  Do it with
++	 * interrupts disabled.
++	 */
++	spin_lock_irqsave(&up->port.lock, flags);
++
++	/*
++	 * Update the per-port timeout.
++	 */
++	uart_update_timeout(port, termios->c_cflag, baud);
++
++	up->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_PE | UART_LSR_DR;
++	if (termios->c_iflag & INPCK)
++		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
++	if (termios->c_iflag & (BRKINT | PARMRK))
++		up->port.read_status_mask |= UART_LSR_BI;
++
++	/*
++	 * Characteres to ignore
++	 */
++	up->port.ignore_status_mask = 0;
++	if (termios->c_iflag & IGNPAR)
++		up->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
++	if (termios->c_iflag & IGNBRK) {
++		up->port.ignore_status_mask |= UART_LSR_BI;
++		/*
++		 * If we're ignoring parity and break indicators,
++		 * ignore overruns too (for real raw support).
++		 */
++		if (termios->c_iflag & IGNPAR)
++			up->port.ignore_status_mask |= UART_LSR_OE;
++	}
++
++	/*
++	 * ignore all characters if CREAD is not set
++	 */
++	if ((termios->c_cflag & CREAD) == 0)
++		up->port.ignore_status_mask |= UART_LSR_DR;
++
++	/*
++	 * CTS flow control flag and modem status interrupts
++	 */
++	up->ier &= ~UART_IER_MSI;
++	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
++		up->ier |= UART_IER_MSI;
++
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		printk(KERN_INFO"channelnum %d: serialxr_set_termios1 - LCR = 0x%x",	up->channelnum, lcr);
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_IER, up->ier);
++	reg_read=serial_in(up, XR_17V35X_EXTENDED_EFR);
++
++	if(termios->c_cflag & CRTSCTS)
++	{
++	    serial_out(up, XR_17V35X_EXTENDED_EFR, reg_read|0xC0);
++	    printk(KERN_INFO "Hardware Flow Control Enabled");	    
++	}
++	 else
++	 {
++	       serial_out(up, XR_17V35X_EXTENDED_EFR, reg_read & 0x3F);
++	       printk(KERN_INFO "Hardware Flow Control Disabled\n");	    
++	 }
++	
++	/*
++	*	Auto XON/XOFF software flow control flags
++	*/
++	
++	serial_out(up, XR_17V35X_UART_XON1,0x11); //Initializing XON1
++	serial_out(up, XR_17V35X_UART_XOFF1,0x13); //Initializing XOFF1
++
++	if(((termios->c_iflag) & IXOFF)&&((termios->c_iflag) & IXON))
++	{
++		serial_out(up, XR_17V35X_EXTENDED_EFR, (reg_read) | 0x0A );
++		printk(KERN_INFO "Software Flow Control Enabled\n");
++	}
++	else 
++	{
++		serial_out(up, XR_17V35X_EXTENDED_EFR, (reg_read) & 0xF0 );
++		printk(KERN_INFO "No Software Flow Control\n");
++	}
++	
++	reg_read=serial_in(up, XR_17V35X_EXTENDED_EFR);
++	
++	if((termios->c_iflag) & IXANY)
++	{
++		serial_out(up, XR_17V35X_EXTENDED_EFR, ((termios->c_iflag) & IXOFF)||((termios->c_iflag) & IXON)?((reg_read) | 0x1A):((reg_read) | 0x10));
++		reg_read=serial_in(up, UART_MCR);
++		serial_out(up, UART_MCR, (reg_read) | 0x20 );
++		serial_out(up, XR_17V35X_EXTENDED_EFR, (reg_read) & 0xEF );
++		printk(KERN_INFO "AUTO XANY Enabled\n");
++	}
++	else 
++	{
++		serial_out(up, XR_17V35X_EXTENDED_EFR, (reg_read) | 0x10 );
++		reg_read=serial_in(up, UART_MCR);
++		serial_out(up, UART_MCR, (reg_read) & 0xDF );
++		reg_read=serial_in(up,XR_17V35X_EXTENDED_EFR);
++		serial_out(up, XR_17V35X_EXTENDED_EFR, (reg_read) & 0xEF );
++		printk(KERN_INFO "AUTO XANY NOT Enabled\n");
++	}
++	
++//---------------------------------------------------------------------------//
++	
++	serial_out(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
++	
++	serial_out(up, UART_DLL, quot & 0xff);		/* LS of divisor */
++	serial_out(up, UART_DLM, quot >> 8);		/* MS of divisor */
++	//Fractional baud rate support
++	if((up->deviceid == 0x152)||(up->deviceid == 0x154)||(up->deviceid == 0x158))
++	{
++		//nothing to do , because these devices do not have support for the DLD register.
++	}
++	else
++	{
++	  reg_read=(serial_in(up, XR_17V35X_UART_DLD)&0xF0);
++	  DEBUG_INTR(KERN_INFO "serialxr_set_termios: quot =0x%x quot_fraction=0x%x DLD_reg=0x%x\n",quot,quot_fraction,reg_read);		
++	  serial_out(up, XR_17V35X_UART_DLD, quot_fraction | reg_read);
++	  reg_read=serial_in(up, XR_17V35X_UART_DLD);
++	}
++	serial_out(up, UART_LCR, cval);		/* reset DLAB */
++	up->lcr = cval;						/* Save LCR */
++	
++	lcr = serial_in(up, UART_LCR);
++	if (lcr & 0x80) {
++		printk(KERN_INFO"channelnum %d: serialxr_set_termios2 - LCR = 0x%x", up->channelnum, lcr);
++		serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++	}
++	serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);/* set fcr */
++	/*
++		Configuring MPIO as inputs
++	*/
++	if((up->deviceid == 0x354)||(up->deviceid == 0x4354)||(up->deviceid == 0x8354))
++	{
++		serial_out(up, XR_17V35x_MPIOSEL_7_0,0x0FF); //0x0ff= ALL INPUTS	
++	}
++	else if((up->deviceid == 0x358)||(up->deviceid == 0x4358)||(up->deviceid == 0x8358))
++	{
++		serial_out(up, XR_17V35x_MPIOSEL_7_0,0x0FF); //0x0ff= ALL INPUTS
++		serial_out(up, XR_17V35x_MPIOSEL_15_8,0x0FF); //0x0ff= ALL INPUTS
++	}
++	
++	serialxr_set_mctrl(&up->port, up->port.mctrl);
++#if ENABLE_INTERNAL_LOOPBACK
++	reg_read=serial_in(up, UART_MCR);
++	serial_out(up, UART_MCR, (reg_read) | 0x10);
++	printk(KERN_INFO "Enabling Internal Loopback\n");
++#endif
++	spin_unlock_irqrestore(&up->port.lock, flags);
++}
++
++/*
++ *      EXAR ioctls
++ */
++//#define 	FIOQSIZE		0x5460 
++#define		EXAR_READ_REG      	(FIOQSIZE + 1)
++#define 	EXAR_WRITE_REG     	(FIOQSIZE + 2)
++
++#define 	EXAR_SET_MULTIDROP_MODE_NORMAL   (FIOQSIZE + 3)
++#define 	EXAR_SET_MULTIDROP_MODE_AUTO     (FIOQSIZE + 4)
++#define 	EXAR_SET_REMOVE_MULTIDROP_MODE   (FIOQSIZE + 5)
++#define 	EXAR_SET_NON_STANDARD_BAUDRATE   (FIOQSIZE + 6)
++
++
++
++struct xrioctl_rw_reg {
++	unsigned char reg;
++	unsigned char regvalue;
++};
++/*
++ * This function is used to handle Exar Device specific ioctl calls
++ * The user level application should have defined the above ioctl
++ * commands with the above values to access these ioctls and the 
++ * input parameters for these ioctls should be struct xrioctl_rw_reg
++ * The Ioctl functioning is pretty much self explanatory here in the code,
++ * and the register values should be between 0 to XR_17V35X_EXTENDED_RXTRG
++ */
++
++static int
++serialxr_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	int ret = -ENOIOCTLCMD;
++	struct xrioctl_rw_reg ioctlrwarg;
++    unsigned char address;
++	unsigned char tmp,lcr_bak,dld,efr;
++	unsigned int any_baudrate = 0;
++	switch (cmd)
++	{
++		case EXAR_READ_REG:
++		if (copy_from_user(&ioctlrwarg, (void *)arg, sizeof(ioctlrwarg)))
++			return -EFAULT;
++		ioctlrwarg.regvalue = serial_in(up, ioctlrwarg.reg);
++		if (copy_to_user((void *)arg, &ioctlrwarg, sizeof(ioctlrwarg)))
++			return -EFAULT;
++		DEBUG_INTR(KERN_INFO "serialxr_ioctl read reg[0x%02x]=0x%02x \n",ioctlrwarg.reg,ioctlrwarg.regvalue);
++		ret = 0;
++		break;
++		
++		case EXAR_WRITE_REG:
++		if (copy_from_user(&ioctlrwarg, (void *)arg, sizeof(ioctlrwarg)))
++			return -EFAULT;
++		serial_out(up, ioctlrwarg.reg, ioctlrwarg.regvalue);
++		DEBUG_INTR(KERN_INFO "serialxr_ioctl write reg[0x%02x]=0x%02x \n",ioctlrwarg.reg,ioctlrwarg.regvalue);
++		ret = 0;
++		break;
++		case EXAR_SET_MULTIDROP_MODE_NORMAL:
++		if (copy_from_user(&address, (void *)arg, 1))
++			return -EFAULT;
++		   
++		    up->multidrop_address = address;
++			//set EFR[4] = 1; enable the shaded bits 
++			efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++			efr |=0x10;
++			serial_out(up, XR_17V35X_EXTENDED_EFR, efr);
++			
++			serial_out(up,XR_17V35X_UART_MSR, 0x04);//Disable the receiver with mode=0
++            //set EFR[4] =0; disable the shaded bits 
++			efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++			efr &=~0x10;
++			serial_out(up, XR_17V35X_EXTENDED_EFR, efr); 
++			
++			
++			lcr_bak = serial_in(up, UART_LCR);
++			tmp = 0x80 | lcr_bak | 0x38; //LCR[7]=1 for access DLD  LCR[5:3] = '111'  for Forced parity to space "0"
++			serial_out(up, UART_LCR, tmp);
++			//set the DLD[6] = 1 enable Multidrop mode
++			dld = serial_in(up, XR_17V35X_UART_DLD);
++			dld |= 0x40;
++			serial_out(up, XR_17V35X_UART_DLD, dld);
++			
++			//set EFR[5] = 0; disable the special char Select
++			efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++			efr &=~0x20;
++			serial_out(up, XR_17V35X_EXTENDED_EFR, efr);
++			
++		    lcr_bak = serial_in(up, UART_LCR);//set LCR[7]=0
++			lcr_bak &=~0x80;
++			serial_out(up, UART_LCR, lcr_bak);
++			
++			ret = 0;
++			up->multidrop_mode = 1;//for enable multidrop normal mode 
++			up->is_match_address = 0;
++			DEBUG_INTR(KERN_INFO "User request EXAR_SET_MULTIDROP_MODE_NORMAL addr:%d \n",up->multidrop_address);
++		    break;
++		
++		case EXAR_SET_MULTIDROP_MODE_AUTO:
++		if (copy_from_user(&address, (void *)arg, 1))
++			return -EFAULT;
++		    up->multidrop_address = address;
++			
++			serial_out(up, XR_17V35X_UART_XOFF2,address);
++			
++            //set EFR[4] = 1; enable the shaded bits 
++			efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++			efr |=0x10;
++			serial_out(up, XR_17V35X_EXTENDED_EFR, efr);
++			
++			serial_out(up,XR_17V35X_UART_MSR, 0x04);//Disable the receiver with mode=0
++			 //set EFR[4] =0; disable the shaded bits 
++			efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++			efr &=~0x10;
++			serial_out(up, XR_17V35X_EXTENDED_EFR, efr); 
++			
++		    lcr_bak = serial_in(up, UART_LCR);
++			tmp = 0x80 | lcr_bak | 0x38; //LCR[7]=1 for access DLD  LCR[5:3] = '111'  for Forced parity to space "0"
++			serial_out(up, UART_LCR, tmp);
++			
++			//set the DLD[6] = 1 enable Multidrop mode
++			dld = serial_in(up, XR_17V35X_UART_DLD);
++			dld |= 0x40;
++			serial_out(up, XR_17V35X_UART_DLD, dld);
++			
++			//set EFR[5] = 1; enable the special char Select
++			efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++			efr |=0x20;
++			serial_out(up, XR_17V35X_EXTENDED_EFR, efr);
++			//printk(KERN_INFO "UART_EFR=0x%02x\n",serial_in(up, XR_17V35X_EXTENDED_EFR));
++						
++			up->multidrop_mode = 2;//for enable multidrop auto mode 
++
++			lcr_bak = serial_in(up, UART_LCR);//set LCR[7]=0
++			lcr_bak &=~0x80;
++			serial_out(up, UART_LCR, lcr_bak);
++			
++			DEBUG_INTR(KERN_INFO "User request EXAR_SET_MULTIDROP_MODE_AUTO addr:%d \n",up->multidrop_address);
++			ret = 0;	
++			break;
++		case EXAR_SET_REMOVE_MULTIDROP_MODE:
++			//set the DLD[6] = 0 disable Multidrop mode
++			lcr_bak = serial_in(up, UART_LCR);
++			tmp = 0x80 | lcr_bak; //LCR[7]=1 for access DLD
++			
++			dld = serial_in(up, XR_17V35X_UART_DLD);
++			dld &=~0x40;//Disable Multidrop mode
++			serial_out(up, XR_17V35X_UART_DLD, tmp);
++					
++			efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++			efr &=~0x20;//disable the special char select
++			efr |= 0x10; //enable the shaded bits 
++			serial_out(up, XR_17V35X_EXTENDED_EFR, efr);
++
++			
++			serial_out(up,XR_17V35X_UART_MSR, 0x00);//Enable the receiver with mode=0
++			
++             //set EFR[4] =0; disable the shaded bits 
++			efr = serial_in(up, XR_17V35X_EXTENDED_EFR);
++			efr &=~0x10;
++			serial_out(up, XR_17V35X_EXTENDED_EFR, efr);  
++			
++            lcr_bak &=~0x38;//LCR[5:3] = '000'  
++            lcr_bak &=~0x80;//Set LCR[7] = 0 
++			serial_out(up, UART_LCR, lcr_bak);
++			up->multidrop_mode = 0;
++			up->is_match_address = 0;
++		    ret = 0;	
++		   
++		break;
++		case EXAR_SET_NON_STANDARD_BAUDRATE:
++		if (copy_from_user(&any_baudrate, (void *)arg, sizeof(unsigned int)))
++		{
++		   return -EFAULT;	
++		}
++		serialxr_set_special_baudrate(port,any_baudrate);
++		break;
++		
++	}
++	
++	return ret;
++}
++	      
++static void
++serialxr_pm(struct uart_port *port, unsigned int state,
++	      unsigned int oldstate)
++{
++	int lcr;	
++	struct uart_xr_port *up = (struct uart_xr_port *)port;
++	if (state) {
++		/* sleep */
++		serial_out(up, XR_17V35X_EXTENDED_EFR, UART_EFR_ECB);
++		lcr = serial_in(up, UART_LCR);
++		if (lcr & 0x80) {
++			printk(KERN_INFO"channelnum %d: serialxr_pm sleep - LCR = 0x%x", up->channelnum, lcr);
++			serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++		}
++		serial_out(up, UART_IER, UART_IERX_SLEEP);
++		serial_out(up, XR_17V35X_EXTENDED_EFR, 0);
++	} else {
++		/* wake */
++		serial_out(up, XR_17V35X_EXTENDED_EFR, UART_EFR_ECB);
++		lcr = serial_in(up, UART_LCR);
++		if (lcr & 0x80) {
++			printk(KERN_INFO"channelnum %d: serialxr_pm wake - LCR = 0x%x", up->channelnum, lcr);
++			serial_out(up, UART_LCR, lcr & 0x7f);	// Set LCR bit-7=0 when accessing RHR/THR/IER/ISR to avoid incorrect register access
++		}
++		serial_out(up, UART_IER, 0);
++		serial_out(up, XR_17V35X_EXTENDED_EFR, 0);
++	}
++
++	if (up->pm)
++		up->pm(port, state, oldstate);
++}
++
++static void serialxr_release_port(struct uart_port *port)
++{	
++}
++
++static int serialxr_request_port(struct uart_port *port)
++{
++	return 0;
++}
++
++static void serialxr_config_port(struct uart_port *port, int flags)
++{
++	struct uart_xr_port *up = (struct uart_xr_port *)port;	
++
++	if (flags & UART_CONFIG_TYPE)
++	{	
++		if(up->deviceid > 0x258) // PCIe device
++		{
++			up->port.type = XRPCIe_TYPE;
++		}
++		else
++		{
++			up->port.type = XRPCI25x_TYPE;
++		}
++		up->port.fifosize = uart_config[up->port.type].dfl_xmit_fifo_size;
++		up->capabilities = uart_config[up->port.type].flags;	
++	}
++}
++
++static const char *
++serialxr_type(struct uart_port *port)
++{
++	int type = port->type;
++	
++	if (type >= ARRAY_SIZE(uart_config))
++		type = 0;
++	return uart_config[type].name;
++}
++
++static struct uart_ops serialxr_pops = {
++	.tx_empty	= serialxr_tx_empty,
++	.set_mctrl	= serialxr_set_mctrl,
++	.get_mctrl	= serialxr_get_mctrl,
++	.stop_tx	= serialxr_stop_tx,
++	.start_tx	= serialxr_start_tx,
++	.stop_rx	= serialxr_stop_rx,
++	.enable_ms	= serialxr_enable_ms,
++	.break_ctl	= serialxr_break_ctl,
++	.startup	= serialxr_startup,
++	.shutdown	= serialxr_shutdown,
++	.set_termios	= serialxr_set_termios,
++	.pm		= serialxr_pm,
++	.type		= serialxr_type,
++	.release_port	= serialxr_release_port,
++	.request_port	= serialxr_request_port,
++	.config_port	= serialxr_config_port,
++	.ioctl		= serialxr_ioctl,
++};
++
++static DEFINE_MUTEX(serial_mutex);
++
++static struct uart_xr_port serialxr_ports[NR_PORTS];
++
++#define SERIALXR_CONSOLE	NULL
++
++static struct uart_driver xr_uart_driver = {
++	.owner			= THIS_MODULE,
++	.driver_name		= "xrserial",
++	.dev_name		= "ttyXR",
++	.major			= XR_MAJOR,
++	.minor			= XR_MINOR,
++	.nr			= NR_PORTS,
++	.cons			= SERIALXR_CONSOLE,
++};
++
++static struct uart_xr_port *serialxr_find_match_or_unused(struct uart_port *port)
++{
++	int i;
++
++	/*
++	 * First, find a port entry which matches.
++	 */
++	for (i = 0; i < NR_PORTS; i++)
++		if (uart_match_port(&serialxr_ports[i].port, port))
++			return &serialxr_ports[i];
++
++	/*
++	 * We didn't find a matching entry, so look for the first
++	 * free entry.  We look for one which hasn't been previously
++	 * used (indicated by zero iobase).
++	 */
++	for (i = 0; i < NR_PORTS; i++)
++		if (serialxr_ports[i].port.type == PORT_UNKNOWN &&
++		    serialxr_ports[i].port.iobase == 0)
++		{
++			port->line = i;
++			return &serialxr_ports[i];
++		}
++
++	/*
++	 * That also failed.  Last resort is to find any entry which
++	 * doesn't have a real port associated with it.
++	 */
++	for (i = 0; i < NR_PORTS; i++)
++		if (serialxr_ports[i].port.type == PORT_UNKNOWN)
++			return &serialxr_ports[i];
++
++	return NULL;
++}
++
++
++/*
++ *	serialxr_register_port - register a serial port
++ *	@port: serial port template
++ *
++ *	Configure the serial port specified by the request. If the
++ *	port exists and is in use, it is hung up and unregistered
++ *	first.
++ *
++ *	The port is then probed and if necessary the IRQ is autodetected
++ *	If this fails an error is returned.
++ *
++ *	On success the port is ready to use and the line number is returned.
++ */
++int serialxr_register_port(struct uart_port *port, unsigned short deviceid, unsigned char channelnum)
++{
++	struct uart_xr_port *uart;
++	int ret = -ENOSPC;
++
++	if (port->uartclk == 0)
++		return -EINVAL;
++
++	mutex_lock(&serial_mutex);
++	uart = serialxr_find_match_or_unused(port);
++	if (uart) {
++		uart->port.iobase   = port->iobase;
++		uart->port.membase  = port->membase;
++		uart->port.irq      = port->irq;
++		uart->port.uartclk  = port->uartclk;
++		uart->port.fifosize = port->fifosize;
++		uart->port.regshift = port->regshift;
++		uart->port.iotype   = port->iotype;
++		uart->port.flags    = port->flags | UPF_BOOT_AUTOCONF;
++		uart->port.mapbase  = port->mapbase;
++		if (port->dev)
++			uart->port.dev = port->dev;
++
++		uart->deviceid = deviceid;
++		uart->channelnum = channelnum;
++		uart->port.line = port->line;
++		spin_lock_init(&uart->port.lock);
++
++		#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
++		timer_setup(&uart->timer, serialxr_timeout, 0);
++		#else
++		init_timer(&uart->timer);
++		uart->timer.function = serialxr_timeout;
++		#endif
++
++		/*
++		 * ALPHA_KLUDGE_MCR needs to be killed.
++		 */
++		uart->mcr_mask = ~(0x0); //~ALPHA_KLUDGE_MCR;
++		uart->mcr_force = 0; // ALPHA_KLUDGE_MCR;
++
++		uart->port.ops = &serialxr_pops;		
++		
++		ret = uart_add_one_port(&xr_uart_driver, &uart->port);
++#if 0
++		if (ret == 0)
++		{
++			ret = uart->port.line;
++
++			if (is_real_interrupt(uart->port.irq)) {
++				serial_link_irq_chain(uart);
++			}
++		}
++#endif
++	}
++	mutex_unlock(&serial_mutex);
++
++	return ret;
++}
++
++/*
++ * Probe one serial board.  Unfortunately, there is no rhyme nor reason
++ * to the arrangement of serial ports on a PCI card.
++ */
++static int __devinit
++init_one_xrpciserialcard(struct pci_dev *dev, const struct pci_device_id *ent)
++{
++	struct serial_private *priv;
++	struct pciserial_board *board;
++	struct pci_serial_quirk *quirk;
++	struct uart_port serial_port;
++	int rc, nr_ports, i;
++			
++	if (ent->driver_data >= ARRAY_SIZE(xrpciserial_boards)) {
++		printk(KERN_INFO "pci_init_one: invalid driver_data: %ld\n",
++			ent->driver_data);
++		return -EINVAL;
++	}
++
++	board = &xrpciserial_boards[ent->driver_data];
++
++	rc = pci_enable_device(dev);
++	if (rc)
++		return rc;
++	
++	nr_ports = board->num_ports;
++
++	/*
++	 * Find an init and setup quirks.
++	 */
++	quirk = find_quirk(dev);
++
++	/*
++	 * Run the new-style initialization function.
++	 * The initialization function returns:
++	 *  <0  - error
++	 *   0  - use board->num_ports
++	 *  >0  - number of ports
++	 */
++	if (quirk->init) {
++		rc = quirk->init(dev);
++		if (rc < 0)
++			goto disable;
++		if (rc)
++			nr_ports = rc;
++	}
++
++	priv = kmalloc(sizeof(struct serial_private) +
++		       sizeof(unsigned int) * nr_ports,
++		       GFP_KERNEL);
++	if (!priv) {
++		rc = -ENOMEM;
++		goto deinit;
++	}
++
++	memset(priv, 0, sizeof(struct serial_private) +
++			sizeof(unsigned int) * nr_ports);
++
++	priv->dev = dev;
++	priv->quirk = quirk;
++
++	memset(&serial_port, 0, sizeof(struct uart_port));
++	serial_port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;
++
++	if((priv->dev->device == 0x152)	||(priv->dev->device == 0x154)||(priv->dev->device == 0x158))
++		serial_port.uartclk = board->base_baud * 16;
++	else
++		serial_port.uartclk = board->base_baud * 4;
++	serial_port.irq = dev->irq;
++	serial_port.dev = &dev->dev;
++	for (i = 0; i < nr_ports; i++) {
++		if (quirk->setup(priv, board, &serial_port, i))
++			break;
++
++		// setup the uartclock for the devices on expansion slot
++		switch(priv->dev->device)
++		{
++		    case 0x4354:	      
++		    case 0x8354:
++		      if(i >= 4)
++			serial_port.uartclk = 62500000; // half the clock speed of the main chip (which is 125MHz)
++		      break;
++
++		    case 0x4358:	      
++		    case 0x8358:
++		      if(i >= 8) // epansions slot ports
++			serial_port.uartclk = 62500000; // half the clock speed of the main chip (which is 125MHz)
++		      break;
++
++		    default: //0x358/354/352/258/254/252
++		    break;
++		}
++
++		rc = serialxr_register_port(&serial_port, dev->device,i);
++		if (rc < 0) {
++			printk(KERN_WARNING "Couldn't register serial port %s: %d\n", pci_name(dev), i);
++			break;
++		}
++				
++		printk(KERN_WARNING "init_one_xrpciserialcard line:%d\n",serial_port.line);
++		priv->uart_index[i] = serial_port.line;
++		priv->line[i] = rc;
++		
++		
++	}
++
++	priv->nr = i;
++
++	if (!IS_ERR(priv)) {
++		pci_set_drvdata(dev, priv);
++		return 0;
++	}
++
++ deinit:
++	if (quirk->exit)
++		quirk->exit(dev);
++ disable:
++	pci_disable_device(dev);
++	return rc;
++}
++
++/*
++ *	serialxr_unregister_port - remove a serial port at runtime
++ *	@line: serial line number
++ *
++ *	Remove one serial port.  This may not be called from interrupt
++ *	context.  We hand the port back to the our control.
++ */
++void serialxr_unregister_port(int line)
++{
++	struct uart_xr_port *uart = &serialxr_ports[line];
++
++	mutex_lock(&serial_mutex);
++#if 0
++	if (is_real_interrupt(uart->port.irq))
++	  serial_unlink_irq_chain(uart);
++#endif
++	uart_remove_one_port(&xr_uart_driver, &uart->port);
++	uart->port.dev = NULL;	
++	mutex_unlock(&serial_mutex);
++}
++
++void pciserial_remove_ports_xr17v35x(struct serial_private *priv)
++{
++	struct pci_serial_quirk *quirk;
++	int i;
++
++	for (i = 0; i < priv->nr; i++)
++	{
++	  	printk(KERN_WARNING "pciserial_remove_ports dev:%p port_num:%d\n",priv->dev,priv->uart_index[i]);
++		//serialxr_unregister_port(priv->line[i]);
++		serialxr_unregister_port(priv->uart_index[i]);
++		
++	}	
++
++	for (i = 0; i < PCI_NUM_BAR_RESOURCES; i++) {
++		if (priv->remapped_bar[i])
++			iounmap(priv->remapped_bar[i]);
++		priv->remapped_bar[i] = NULL;
++	}
++
++	/*
++	 * Find the exit quirks.
++	 */
++	quirk = find_quirk(priv->dev);
++	if (quirk->exit)
++		quirk->exit(priv->dev);
++
++	kfree(priv);
++}
++
++static void __devexit remove_one_xrpciserialcard(struct pci_dev *dev)
++{
++	struct serial_private *priv = pci_get_drvdata(dev);
++
++	pci_set_drvdata(dev, NULL);
++
++	pciserial_remove_ports_xr17v35x(priv);
++
++	pci_disable_device(dev);
++}
++
++
++static struct pci_device_id xrserial_pci_tbl[] = {
++	{	0x13a8, 0x358,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_8port },
++	{	0x13a8, 0x354,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_4port },
++	{	0x13a8, 0x352,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_2port },
++	{	0x13a8, 0x4354,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_4354port },
++	{	0x13a8, 0x8354,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_8354port },
++	{	0x13a8, 0x4358,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_4358port },
++	{	0x13a8, 0x8358,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_8358port },
++	{	0x13a8, 0x258,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_258port },
++	{	0x13a8, 0x254,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_254port },
++	{	0x13a8, 0x252,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_252port },
++	{	0x13a8, 0x158,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_158port },
++	{	0x13a8, 0x154,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_154port },
++	{	0x13a8, 0x152,
++		PCI_ANY_ID, PCI_ANY_ID,
++		0, 0, xr_152port },
++
++	{ 0, }
++};
++
++static struct pci_driver xrserial_pci_driver = {
++	.name		= "xrserial",
++	.probe		= init_one_xrpciserialcard,
++	.remove		= __devexit_p(remove_one_xrpciserialcard),
++	.id_table	= xrserial_pci_tbl,
++};
++
++static int __init serialxr_init(void)
++{
++	int ret;
++
++	printk(KERN_INFO "Exar PCIe (XR17V35x) serial driver Revision: 2.6\n");
++
++	ret = uart_register_driver(&xr_uart_driver);
++	if (ret)
++		return ret;
++
++	ret = pci_register_driver(&xrserial_pci_driver);
++
++	if (ret < 0)
++		uart_unregister_driver(&xr_uart_driver);
++
++	return ret;	
++}
++
++static void __exit serialxr_exit(void)
++{
++	pci_unregister_driver(&xrserial_pci_driver);
++	uart_unregister_driver(&xr_uart_driver);
++}
++
++module_init(serialxr_init);
++module_exit(serialxr_exit);
++
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("Exar PCIe specific serial driver for XR17V35x- Revision: 2.6");
+diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
+index b878f4c87fee..21623499015e 100644
+--- a/drivers/usb/serial/option.c
++++ b/drivers/usb/serial/option.c
+@@ -252,10 +252,14 @@ static void option_instat_callback(struct urb *urb);
+ #define QUECTEL_PRODUCT_EG95			0x0195
+ #define QUECTEL_PRODUCT_BG96			0x0296
+ #define QUECTEL_PRODUCT_EP06			0x0306
++#define QUECTEL_PRODUCT_EM05G			0x030a
++#define QUECTEL_PRODUCT_EM060K			0x030b
+ #define QUECTEL_PRODUCT_EM12			0x0512
+ #define QUECTEL_PRODUCT_RM500Q			0x0800
++#define QUECTEL_PRODUCT_RM520N			0x0801
+ #define QUECTEL_PRODUCT_EC200S_CN		0x6002
+ #define QUECTEL_PRODUCT_EC200T			0x6026
++#define QUECTEL_PRODUCT_RM500K			0x7001
+ 
+ #define CMOTECH_VENDOR_ID			0x16d8
+ #define CMOTECH_PRODUCT_6001			0x6001
+@@ -350,6 +354,7 @@ static void option_instat_callback(struct urb *urb);
+ #define TOSHIBA_PRODUCT_G450			0x0d45
+ 
+ #define ALINK_VENDOR_ID				0x1e0e
++#define SIMCOM_VENDOR_ID			0x1e0e
+ #define SIMCOM_PRODUCT_SIM7100E			0x9001 /* Yes, ALINK_VENDOR_ID */
+ #define ALINK_PRODUCT_PH300			0x9100
+ #define ALINK_PRODUCT_3GU			0x9200
+@@ -432,6 +437,12 @@ static void option_instat_callback(struct urb *urb);
+ #define CINTERION_PRODUCT_CLS8			0x00b0
+ #define CINTERION_PRODUCT_MV31_MBIM		0x00b3
+ #define CINTERION_PRODUCT_MV31_RMNET		0x00b7
++#define CINTERION_PRODUCT_MV31_2_MBIM		0x00b8
++#define CINTERION_PRODUCT_MV31_2_RMNET		0x00b9
++#define CINTERION_PRODUCT_MV32_WA		0x00f1
++#define CINTERION_PRODUCT_MV32_WB		0x00f2
++#define CINTERION_PRODUCT_MV32_WA_RMNET		0x00f3
++#define CINTERION_PRODUCT_MV32_WB_RMNET		0x00f4
+ 
+ /* Olivetti products */
+ #define OLIVETTI_VENDOR_ID			0x0b3c
+@@ -567,6 +578,10 @@ static void option_instat_callback(struct urb *urb);
+ #define WETELECOM_PRODUCT_6802			0x6802
+ #define WETELECOM_PRODUCT_WMD300		0x6803
+ 
++/* OPPO products */
++#define OPPO_VENDOR_ID				0x22d9
++#define OPPO_PRODUCT_R11			0x276c
++
+ 
+ /* Device flags */
+ 
+@@ -1125,22 +1140,35 @@ static const struct usb_device_id option_ids[] = {
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EG95, 0xff, 0xff, 0xff),
+ 	  .driver_info = NUMEP2 },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EG95, 0xff, 0, 0) },
++	{ USB_DEVICE_INTERFACE_CLASS(QUECTEL_VENDOR_ID, 0x0203, 0xff), /* BG95-M3 */
++	  .driver_info = ZLP },
+ 	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96),
+ 	  .driver_info = RSVD(4) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0xff, 0xff),
+ 	  .driver_info = RSVD(1) | RSVD(2) | RSVD(3) | RSVD(4) | NUMEP2 },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0, 0) },
++	{ USB_DEVICE_INTERFACE_CLASS(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EM05G, 0xff),
++	  .driver_info = RSVD(6) | ZLP },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EM060K, 0xff, 0x00, 0x40) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EM060K, 0xff, 0xff, 0x30) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EM060K, 0xff, 0xff, 0x40) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EM12, 0xff, 0xff, 0xff),
+ 	  .driver_info = RSVD(1) | RSVD(2) | RSVD(3) | RSVD(4) | NUMEP2 },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EM12, 0xff, 0, 0) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, 0x0620, 0xff, 0xff, 0x30) },	/* EM160R-GL */
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, 0x0620, 0xff, 0, 0) },
++	{ USB_DEVICE_INTERFACE_CLASS(QUECTEL_VENDOR_ID, 0x0700, 0xff), /* BG95 */
++	  .driver_info = RSVD(3) | ZLP },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM500Q, 0xff, 0xff, 0x30) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM500Q, 0xff, 0, 0) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM500Q, 0xff, 0xff, 0x10),
+ 	  .driver_info = ZLP },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM520N, 0xff, 0xff, 0x30) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM520N, 0xff, 0, 0x40) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM520N, 0xff, 0, 0) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC200S_CN, 0xff, 0, 0) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC200T, 0xff, 0, 0) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM500K, 0xff, 0x00, 0x00) },
+ 
+ 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
+ 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
+@@ -1217,6 +1245,10 @@ static const struct usb_device_id option_ids[] = {
+ 	  .driver_info = NCTRL(0) | RSVD(1) },
+ 	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, 0x1056, 0xff),	/* Telit FD980 */
+ 	  .driver_info = NCTRL(2) | RSVD(3) },
++	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, 0x1057, 0xff),	/* Telit FN980 */
++	  .driver_info = NCTRL(0) | RSVD(1) | RSVD(2) },
++	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, 0x1058, 0xff),	/* Telit FN980 (PCIe) */
++	  .driver_info = NCTRL(0) | RSVD(1) },
+ 	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, 0x1060, 0xff),	/* Telit LN920 (rmnet) */
+ 	  .driver_info = NCTRL(0) | RSVD(1) | RSVD(2) },
+ 	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, 0x1061, 0xff),	/* Telit LN920 (MBIM) */
+@@ -1233,6 +1265,8 @@ static const struct usb_device_id option_ids[] = {
+ 	  .driver_info = NCTRL(2) | RSVD(3) },
+ 	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, 0x1073, 0xff),	/* Telit FN990 (ECM) */
+ 	  .driver_info = NCTRL(0) | RSVD(1) },
++	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, 0x1075, 0xff),	/* Telit FN990 (PCIe) */
++	  .driver_info = RSVD(0) },
+ 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_ME910),
+ 	  .driver_info = NCTRL(0) | RSVD(1) | RSVD(3) },
+ 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_ME910_DUAL_MODEM),
+@@ -1267,6 +1301,7 @@ static const struct usb_device_id option_ids[] = {
+ 	  .driver_info = NCTRL(0) | RSVD(1) | RSVD(2) },
+ 	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, 0x1231, 0xff),	/* Telit LE910Cx (RNDIS) */
+ 	  .driver_info = NCTRL(2) | RSVD(3) },
++	{ USB_DEVICE_AND_INTERFACE_INFO(TELIT_VENDOR_ID, 0x1250, 0xff, 0x00, 0x00) },	/* Telit LE910Cx (rmnet) */
+ 	{ USB_DEVICE(TELIT_VENDOR_ID, 0x1260),
+ 	  .driver_info = NCTRL(0) | RSVD(1) | RSVD(2) },
+ 	{ USB_DEVICE(TELIT_VENDOR_ID, 0x1261),
+@@ -1890,7 +1925,7 @@ static const struct usb_device_id option_ids[] = {
+ 	{ USB_DEVICE(ALINK_VENDOR_ID, SIMCOM_PRODUCT_SIM7100E),
+ 	  .driver_info = RSVD(5) | RSVD(6) },
+ 	{ USB_DEVICE_INTERFACE_CLASS(0x1e0e, 0x9003, 0xff) },	/* Simcom SIM7500/SIM7600 MBIM mode */
+-	{ USB_DEVICE_INTERFACE_CLASS(0x1e0e, 0x9011, 0xff),	/* Simcom SIM7500/SIM7600 RNDIS mode */
++	{ USB_DEVICE_INTERFACE_CLASS(0x1e0e, 0x9011, 0xff),	/* Simcom SIM7500/SIM7600 RNDIS mode */ /* Simcom SIM8200 RNDIS mode, Reserved the interface for ADB */
+ 	  .driver_info = RSVD(7) },
+ 	{ USB_DEVICE_INTERFACE_CLASS(0x1e0e, 0x9205, 0xff) },	/* Simcom SIM7070/SIM7080/SIM7090 AT+ECM mode */
+ 	{ USB_DEVICE_INTERFACE_CLASS(0x1e0e, 0x9206, 0xff) },	/* Simcom SIM7070/SIM7080/SIM7090 AT-only mode */
+@@ -1969,6 +2004,18 @@ static const struct usb_device_id option_ids[] = {
+ 	  .driver_info = RSVD(3)},
+ 	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_MV31_RMNET, 0xff),
+ 	  .driver_info = RSVD(0)},
++	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_MV31_2_MBIM, 0xff),
++	  .driver_info = RSVD(3)},
++	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_MV31_2_RMNET, 0xff),
++	  .driver_info = RSVD(0)},
++	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_MV32_WA, 0xff),
++	  .driver_info = RSVD(3)},
++	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_MV32_WA_RMNET, 0xff),
++	  .driver_info = RSVD(0) },
++	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_MV32_WB, 0xff),
++	  .driver_info = RSVD(3)},
++	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_MV32_WB_RMNET, 0xff),
++	  .driver_info = RSVD(0) },
+ 	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD100),
+ 	  .driver_info = RSVD(4) },
+ 	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD120),
+@@ -2111,10 +2158,14 @@ static const struct usb_device_id option_ids[] = {
+ 	  .driver_info = RSVD(3) },
+ 	{ USB_DEVICE(0x1508, 0x1001),						/* Fibocom NL668 (IOT version) */
+ 	  .driver_info = RSVD(4) | RSVD(5) | RSVD(6) },
++	{ USB_DEVICE(0x1782, 0x4d10) },						/* Fibocom L610 (AT mode) */
++	{ USB_DEVICE_INTERFACE_CLASS(0x1782, 0x4d11, 0xff) },			/* Fibocom L610 (ECM/RNDIS mode) */
+ 	{ USB_DEVICE(0x2cb7, 0x0104),						/* Fibocom NL678 series */
+ 	  .driver_info = RSVD(4) | RSVD(5) },
+ 	{ USB_DEVICE_INTERFACE_CLASS(0x2cb7, 0x0105, 0xff),			/* Fibocom NL678 series */
+ 	  .driver_info = RSVD(6) },
++	{ USB_DEVICE_INTERFACE_CLASS(0x2cb7, 0x0106, 0xff) },			/* Fibocom MA510 (ECM mode w/ diag intf.) */
++	{ USB_DEVICE_INTERFACE_CLASS(0x2cb7, 0x010a, 0xff) },			/* Fibocom MA510 (ECM mode) */
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2cb7, 0x010b, 0xff, 0xff, 0x30) },	/* Fibocom FG150 Diag */
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2cb7, 0x010b, 0xff, 0, 0) },		/* Fibocom FG150 AT */
+ 	{ USB_DEVICE_INTERFACE_CLASS(0x2cb7, 0x01a0, 0xff) },			/* Fibocom NL668-AM/NL652-EU (laptop MBIM) */
+@@ -2125,6 +2176,7 @@ static const struct usb_device_id option_ids[] = {
+ 	{ USB_DEVICE_INTERFACE_CLASS(0x305a, 0x1404, 0xff) },			/* GosunCn GM500 RNDIS */
+ 	{ USB_DEVICE_INTERFACE_CLASS(0x305a, 0x1405, 0xff) },			/* GosunCn GM500 MBIM */
+ 	{ USB_DEVICE_INTERFACE_CLASS(0x305a, 0x1406, 0xff) },			/* GosunCn GM500 ECM/NCM */
++	{ USB_DEVICE_AND_INTERFACE_INFO(OPPO_VENDOR_ID, OPPO_PRODUCT_R11, 0xff, 0xff, 0x30) },
+ 	{ } /* Terminating entry */
+ };
+ MODULE_DEVICE_TABLE(usb, option_ids);
+diff --git a/nvidia/platform/t19x/jakku/kernel-dts/Makefile b/nvidia/platform/t19x/jakku/kernel-dts/Makefile
+index 925e46f55615..d0c5ca2de1ec 100644
+--- a/nvidia/platform/t19x/jakku/kernel-dts/Makefile
++++ b/nvidia/platform/t19x/jakku/kernel-dts/Makefile
+@@ -24,6 +24,10 @@ dtbo-$(BUILD_ENABLE) += tegra194-p3668-all-p3509-0000-camera-imx477-imx219.dtbo
+ dtbo-$(BUILD_ENABLE) += tegra194-p3668-all-p3509-0000-camera-imx477-dual.dtbo
+ dtbo-$(BUILD_ENABLE) += tegra194-p3668-all-p3509-0000-camera-imx219-dual.dtbo
+ dtbo-$(BUILD_ENABLE) += tegra194-p3668-p3509-overlay.dtbo
++dtb-$(BUILD_ENABLE) += tegra194-p3668-dsboard-nx2-0000.dtb
++dtb-$(BUILD_ENABLE) += tegra194-p3668-dsboard-nx2-0000-imx477.dtb
++dtb-$(BUILD_ENABLE) += tegra194-p3668-dsboard-nx2-0000-rev121.dtb
++dtb-$(BUILD_ENABLE) += tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dtb
+ 
+ ifneq ($(dtb-y),)
+ dtb-y := $(addprefix $(makefile-path)/,$(dtb-y))
+diff --git a/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-imx477.dts b/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-imx477.dts
+new file mode 100644
+index 000000000000..921897a90383
+--- /dev/null
++++ b/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-imx477.dts
+@@ -0,0 +1,211 @@
++/*
++ * Top level DTS file for CVM:P3668-0001 and CVB:DSBOARD-NX2.
++ *
++ * Copyright (c) 2020-2021, Mist Elektronik Biyomedikal Ltd. Şti.  All rights reserved.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ * more details.
++ */
++
++/dts-v1/;
++#include "common/tegra194-p3668-common.dtsi"
++#include "common/tegra194-p3509-0000-a00.dtsi"
++
++#undef CAM_I2C_MUX
++#define CAM_I2C_MUX TEGRA194_MAIN_GPIO(Q, 6)
++
++/ {
++	nvidia,dtsfilename = __FILE__;
++	nvidia,dtbbuildtime = __DATE__, __TIME__;
++	model = "NVIDIA Jetson Xavier NX for DSBOARD-NX2 (rev-1.22)";
++
++	compatible = "nvidia,p3449-0000+p3668-0000", "nvidia,p3449-0000+p3668-0001", "nvidia,p3509-0000+p3668-0000", "nvidia,p3509-0000+p3668-0001", "nvidia,tegra194";
++
++	i2c@31e0000 {
++		pcf8574a: gpio@38 {
++			status = "okay";
++			compatible = "nxp,pcf8574a";
++			reg = <0x38>;
++			//interrupt-parent = <&irqpin2>;
++			//interrupts = <3 0>;
++			gpio-controller;
++			#gpio-cells = <2>;
++			//interrupt-controller;
++			//#interrupt-cells = <2>;
++		};
++	};
++
++	pcie@141a0000{
++		nvidia,max-speed = <2>;
++	};
++
++	cam_i2cmux{
++		mux-gpios = <&tegra_main_gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
++	};
++
++	sdhci@3440000 {
++		status = "okay";
++		nvidia,vmmc-always-on;
++		disable-wp;
++	};
++
++	sdhci@3400000 {
++		status = "disabled";
++	};
++
++	clocks-init {
++		disable {
++			/delete-property/ clocks;
++		};
++	};
++
++#if TEGRA_PCIE_VERSION < DT_VERSION_2
++	gpio@c2f0000 {
++		w-disable1 {
++			gpio-hog;
++			output-high;
++			gpios = <TEGRA194_AON_GPIO(CC, 2) GPIO_ACTIVE_LOW>;
++			label = "w-disable1";
++			status = "disabled";
++		};
++	};
++#endif
++
++	spi@3210000{
++		status = "okay";
++		nvidia,clock-always-on;
++		spi@0 {
++			status = "okay";
++			compatible = "spidev";
++			reg = <0x0>;
++			spi-max-frequency = <20000000>;
++			nvidia,enable-hw-based-cs;
++			nvidia,enable-hw-based-cs;
++			nvidia,cs-setup-clk-count = <0x1e>;
++			nvidia,cs-hold-clk-count = <0x1e>;
++			nvidia,rx-clk-tap-delay = <0x1f>;
++			nvidia,tx-clk-tap-delay = <0x0>;
++		};
++	};
++
++	/* IMX477 dual sensor module begin */
++	cam_i2cmux {
++		i2c@0 {
++			rbpcv3_imx477_a@1a {
++				status = "okay";
++			};
++			rbpcv2_imx219_a@10 {
++                        	status = "disabled";
++			};
++		};
++		i2c@1 {
++			rbpcv3_imx477_c@1a {
++				status = "okay";
++			};
++			rbpcv2_imx219_c@10 {
++                        	status = "disabled";
++			};
++		};
++	};
++
++	tegra-camera-platform {
++		modules {
++			module0 {
++				status = "okay";
++				badge = "jakku_front_RBPCV3";
++				position = "front";
++				orientation = "1";
++
++				drivernode0 {
++					status = "okay";
++					pcl_id = "v4l2_sensor";
++					devname = "imx477 9-001a";
++					proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/rbpcv3_imx477_a@1a";
++				};
++			};
++			module1 {
++				status = "okay";
++				badge = "jakku_rear_RBPCV3";
++				position = "rear";
++				orientation = "1";
++
++				drivernode0 {
++					status = "okay";
++					pcl_id = "v4l2_sensor";
++					devname = "imx477 10-001a";
++					proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/rbpcv3_imx477_c@1a";
++				};
++			};
++		};
++	};
++
++	tegra-capture-vi {
++		ports {
++			port@0 {
++				endpoint {
++					status = "okay";
++					port-index = <0>;
++					bus-width = <2>;
++					remote-endpoint = <&rbpcv3_imx477_csi_out0>;
++				};
++			};
++			port@1 {
++				endpoint {
++					status = "okay";
++					port-index = <2>;
++					bus-width = <2>;
++					remote-endpoint = <&rbpcv3_imx477_csi_out1>;
++				};
++			};
++		};
++	};
++
++	host1x@13e00000 {
++		nvcsi@15a00000 {
++			channel@0 {
++				ports {
++					port@0 {
++						endpoint@0 {
++							status = "okay";
++							port-index = <0>;
++							bus-width = <2>;
++							remote-endpoint = <&rbpcv3_imx477_out0>;
++						};
++					};
++					port@1 {
++						endpoint@1 {
++							status = "okay";
++						};
++					};
++				};
++			};
++			channel@1 {
++				ports {
++					port@2 {
++						endpoint@2 {
++							status = "okay";
++							port-index = <2>;
++							bus-width = <2>;
++							remote-endpoint = <&rbpcv3_imx477_out1>;
++						};
++					};
++					port@3 {
++						endpoint@3 {
++							status = "okay";
++						};
++					};
++				};
++			};
++		};
++	};
++	/* IMX477 dual sensor module end */
++
++
++};
++
+diff --git a/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dts b/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dts
+new file mode 100644
+index 000000000000..41b7923de56b
+--- /dev/null
++++ b/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-rev121-imx477.dts
+@@ -0,0 +1,216 @@
++/*
++ * Top level DTS file for CVM:P3668-0001 and CVB:DSBOARD-NX2.
++ *
++ * Copyright (c) 2020-2021, Mist Elektronik Biyomedikal Ltd. Şti.  All rights reserved.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ * more details.
++ */
++
++/dts-v1/;
++#include "common/tegra194-p3668-common.dtsi"
++#include "common/tegra194-p3509-0000-a00.dtsi"
++
++#undef CAM_I2C_MUX
++#define CAM_I2C_MUX TEGRA194_MAIN_GPIO(Q, 6)
++
++/ {
++	nvidia,dtsfilename = __FILE__;
++	nvidia,dtbbuildtime = __DATE__, __TIME__;
++	model = "NVIDIA Jetson Xavier NX for DSBOARD-NX2 (rev-1.21; 1.1 & 1.0)";
++
++	compatible = "nvidia,p3449-0000+p3668-0000", "nvidia,p3449-0000+p3668-0001", "nvidia,p3509-0000+p3668-0000", "nvidia,p3509-0000+p3668-0001", "nvidia,tegra194";
++
++	i2c@31e0000 {
++		pcf8574a: gpio@38 {
++			status = "okay";
++			compatible = "nxp,pcf8574a";
++			reg = <0x38>;
++			//interrupt-parent = <&irqpin2>;
++			//interrupts = <3 0>;
++			gpio-controller;
++			#gpio-cells = <2>;
++			//interrupt-controller;
++			//#interrupt-cells = <2>;
++		};
++	};
++
++	pcie@141a0000{
++		nvidia,max-speed = <2>;
++	};
++
++	cam_i2cmux{
++		mux-gpios = <&tegra_main_gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
++	};
++
++	sdhci@3440000 {
++		status = "okay";
++		cd-gpios = <&tegra_main_gpio TEGRA194_MAIN_GPIO(Q, 2) 0>;
++		nvidia,vmmc-always-on;
++		disable-wp;
++	};
++
++	sdhci@3400000 {
++		status = "disabled";
++	};
++
++	pwm-fan {
++		status = "disabled";
++	};
++
++	clocks-init {
++		disable {
++			/delete-property/ clocks;
++		};
++	};
++
++#if TEGRA_PCIE_VERSION < DT_VERSION_2
++	gpio@c2f0000 {
++		w-disable1 {
++			gpio-hog;
++			output-high;
++			gpios = <TEGRA194_AON_GPIO(CC, 2) GPIO_ACTIVE_LOW>;
++			label = "w-disable1";
++			status = "disabled";
++		};
++	};
++#endif
++
++	spi@3210000{
++		status = "okay";
++		nvidia,clock-always-on;
++		spi@0 {
++			status = "okay";
++			compatible = "spidev";
++			reg = <0x0>;
++			spi-max-frequency = <20000000>;
++			nvidia,enable-hw-based-cs;
++			nvidia,enable-hw-based-cs;
++			nvidia,cs-setup-clk-count = <0x1e>;
++			nvidia,cs-hold-clk-count = <0x1e>;
++			nvidia,rx-clk-tap-delay = <0x1f>;
++			nvidia,tx-clk-tap-delay = <0x0>;
++		};
++	};
++
++	/* IMX477 dual sensor module begin */
++	cam_i2cmux {
++		i2c@0 {
++			rbpcv3_imx477_a@1a {
++				status = "okay";
++			};
++			rbpcv2_imx219_a@10 {
++                        	status = "disabled";
++			};
++		};
++		i2c@1 {
++			rbpcv3_imx477_c@1a {
++				status = "okay";
++			};
++			rbpcv2_imx219_c@10 {
++                        	status = "disabled";
++			};
++		};
++	};
++
++	tegra-camera-platform {
++		modules {
++			module0 {
++				status = "okay";
++				badge = "jakku_front_RBPCV3";
++				position = "front";
++				orientation = "1";
++
++				drivernode0 {
++					status = "okay";
++					pcl_id = "v4l2_sensor";
++					devname = "imx477 9-001a";
++					proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/rbpcv3_imx477_a@1a";
++				};
++			};
++			module1 {
++				status = "okay";
++				badge = "jakku_rear_RBPCV3";
++				position = "rear";
++				orientation = "1";
++
++				drivernode0 {
++					status = "okay";
++					pcl_id = "v4l2_sensor";
++					devname = "imx477 10-001a";
++					proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/rbpcv3_imx477_c@1a";
++				};
++			};
++		};
++	};
++
++	tegra-capture-vi {
++		ports {
++			port@0 {
++				endpoint {
++					status = "okay";
++					port-index = <0>;
++					bus-width = <2>;
++					remote-endpoint = <&rbpcv3_imx477_csi_out0>;
++				};
++			};
++			port@1 {
++				endpoint {
++					status = "okay";
++					port-index = <2>;
++					bus-width = <2>;
++					remote-endpoint = <&rbpcv3_imx477_csi_out1>;
++				};
++			};
++		};
++	};
++
++	host1x@13e00000 {
++		nvcsi@15a00000 {
++			channel@0 {
++				ports {
++					port@0 {
++						endpoint@0 {
++							status = "okay";
++							port-index = <0>;
++							bus-width = <2>;
++							remote-endpoint = <&rbpcv3_imx477_out0>;
++						};
++					};
++					port@1 {
++						endpoint@1 {
++							status = "okay";
++						};
++					};
++				};
++			};
++			channel@1 {
++				ports {
++					port@2 {
++						endpoint@2 {
++							status = "okay";
++							port-index = <2>;
++							bus-width = <2>;
++							remote-endpoint = <&rbpcv3_imx477_out1>;
++						};
++					};
++					port@3 {
++						endpoint@3 {
++							status = "okay";
++						};
++					};
++				};
++			};
++		};
++	};
++	/* IMX477 dual sensor module end */
++
++
++};
++
+diff --git a/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-rev121.dts b/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-rev121.dts
+new file mode 100644
+index 000000000000..ef98ece24746
+--- /dev/null
++++ b/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000-rev121.dts
+@@ -0,0 +1,103 @@
++/*
++ * Top level DTS file for CVM:P3668-0001 and CVB:DSBOARD-NX2.
++ *
++ * Copyright (c) 2020-2021, Mist Elektronik Biyomedikal Ltd. Şti.  All rights reserved.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ * more details.
++ */
++
++/dts-v1/;
++#include "common/tegra194-p3668-common.dtsi"
++#include "common/tegra194-p3509-0000-a00.dtsi"
++
++#undef CAM_I2C_MUX
++#define CAM_I2C_MUX TEGRA194_MAIN_GPIO(Q, 6)
++
++/ {
++	nvidia,dtsfilename = __FILE__;
++	nvidia,dtbbuildtime = __DATE__, __TIME__;
++	model = "NVIDIA Jetson Xavier NX for DSBOARD-NX2 (rev-1.21; 1.1 & 1.0)";
++
++	compatible = "nvidia,p3449-0000+p3668-0000", "nvidia,p3449-0000+p3668-0001", "nvidia,p3509-0000+p3668-0000", "nvidia,p3509-0000+p3668-0001", "nvidia,tegra194";
++
++	i2c@31e0000 {
++		pcf8574a: gpio@38 {
++			status = "okay";
++			compatible = "nxp,pcf8574a";
++			reg = <0x38>;
++			//interrupt-parent = <&irqpin2>;
++			//interrupts = <3 0>;
++			gpio-controller;
++			#gpio-cells = <2>;
++			//interrupt-controller;
++			//#interrupt-cells = <2>;
++		};
++	};
++
++	pcie@141a0000{
++		nvidia,max-speed = <2>;
++	};
++
++	cam_i2cmux{
++		mux-gpios = <&tegra_main_gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
++	};
++
++	sdhci@3440000 {
++		status = "okay";
++		cd-gpios = <&tegra_main_gpio TEGRA194_MAIN_GPIO(Q, 2) 0>;
++		nvidia,vmmc-always-on;
++		disable-wp;
++	};
++
++	sdhci@3400000 {
++		status = "disabled";
++	};
++
++	pwm-fan {
++		status = "disabled";
++	};
++
++	clocks-init {
++		disable {
++			/delete-property/ clocks;
++		};
++	};
++
++#if TEGRA_PCIE_VERSION < DT_VERSION_2
++	gpio@c2f0000 {
++		w-disable1 {
++			gpio-hog;
++			output-high;
++			gpios = <TEGRA194_AON_GPIO(CC, 2) GPIO_ACTIVE_LOW>;
++			label = "w-disable1";
++			status = "disabled";
++		};
++	};
++#endif
++
++	spi@3210000{
++		status = "okay";
++		nvidia,clock-always-on;
++		spi@0 {
++			status = "okay";
++			compatible = "spidev";
++			reg = <0x0>;
++			spi-max-frequency = <20000000>;
++			nvidia,enable-hw-based-cs;
++			nvidia,enable-hw-based-cs;
++			nvidia,cs-setup-clk-count = <0x1e>;
++			nvidia,cs-hold-clk-count = <0x1e>;
++			nvidia,rx-clk-tap-delay = <0x1f>;
++			nvidia,tx-clk-tap-delay = <0x0>;
++		};
++	};
++
++};
++
+diff --git a/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000.dts b/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000.dts
+new file mode 100644
+index 000000000000..4cf77f8025db
+--- /dev/null
++++ b/nvidia/platform/t19x/jakku/kernel-dts/tegra194-p3668-dsboard-nx2-0000.dts
+@@ -0,0 +1,98 @@
++/*
++ * Top level DTS file for CVM:P3668-0001 and CVB:DSBOARD-NX2.
++ *
++ * Copyright (c) 2020-2021, Mist Elektronik Biyomedikal Ltd. Şti.  All rights reserved.
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ * more details.
++ */
++
++/dts-v1/;
++#include "common/tegra194-p3668-common.dtsi"
++#include "common/tegra194-p3509-0000-a00.dtsi"
++
++#undef CAM_I2C_MUX
++#define CAM_I2C_MUX TEGRA194_MAIN_GPIO(Q, 6)
++
++/ {
++	nvidia,dtsfilename = __FILE__;
++	nvidia,dtbbuildtime = __DATE__, __TIME__;
++	model = "NVIDIA Jetson Xavier NX for DSBOARD-NX2 (rev-1.22)";
++
++	compatible = "nvidia,p3449-0000+p3668-0000", "nvidia,p3449-0000+p3668-0001", "nvidia,p3509-0000+p3668-0000", "nvidia,p3509-0000+p3668-0001", "nvidia,tegra194";
++
++	i2c@31e0000 {
++		pcf8574a: gpio@38 {
++			status = "okay";
++			compatible = "nxp,pcf8574a";
++			reg = <0x38>;
++			//interrupt-parent = <&irqpin2>;
++			//interrupts = <3 0>;
++			gpio-controller;
++			#gpio-cells = <2>;
++			//interrupt-controller;
++			//#interrupt-cells = <2>;
++		};
++	};
++
++	pcie@141a0000{
++		nvidia,max-speed = <2>;
++	};
++
++	cam_i2cmux{
++		mux-gpios = <&tegra_main_gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
++	};
++
++	sdhci@3440000 {
++		status = "okay";
++		nvidia,vmmc-always-on;
++		disable-wp;
++	};
++
++	sdhci@3400000 {
++		status = "disabled";
++	};
++
++	clocks-init {
++		disable {
++			/delete-property/ clocks;
++		};
++	};
++
++#if TEGRA_PCIE_VERSION < DT_VERSION_2
++	gpio@c2f0000 {
++		w-disable1 {
++			gpio-hog;
++			output-high;
++			gpios = <TEGRA194_AON_GPIO(CC, 2) GPIO_ACTIVE_LOW>;
++			label = "w-disable1";
++			status = "disabled";
++		};
++	};
++#endif
++
++	spi@3210000{
++		status = "okay";
++		nvidia,clock-always-on;
++		spi@0 {
++			status = "okay";
++			compatible = "spidev";
++			reg = <0x0>;
++			spi-max-frequency = <20000000>;
++			nvidia,enable-hw-based-cs;
++			nvidia,enable-hw-based-cs;
++			nvidia,cs-setup-clk-count = <0x1e>;
++			nvidia,cs-hold-clk-count = <0x1e>;
++			nvidia,rx-clk-tap-delay = <0x1f>;
++			nvidia,tx-clk-tap-delay = <0x0>;
++		};
++	};
++
++};
++
+-- 
+2.37.2
+
diff --git a/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra/0001-fix-kernel-headers-test.patch b/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra/0001-fix-kernel-headers-test.patch
index bb79e03..43a79e1 100644
--- a/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra/0001-fix-kernel-headers-test.patch
+++ b/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra/0001-fix-kernel-headers-test.patch
@@ -1,7 +1,9 @@
 From 9deae564cfa83e4396d661fc93eae9b518aba24e Mon Sep 17 00:00:00 2001
 From: Alexandru Costache <alexandru@balena.io>
 Date: Mon, 17 Oct 2022 14:13:52 +0200
-Subject: [PATCH] Not loadable
+Subject: [PATCH] Switch NVMAP_CONFIG_LOADABLE_MODULE to n
+
+To fix a kernel modules headers build error
 
 ---
  nvidia/drivers/video/tegra/nvmap/Makefile.memory.configs | 2 +-
diff --git a/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra_%.bbappend b/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra_%.bbappend
index 8ac4f63..2ab3882 100644
--- a/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra_%.bbappend
+++ b/layers/meta-balena-jetson/recipes-kernel/linux/linux-tegra_%.bbappend
@@ -6,6 +6,7 @@ SCMVERSION="n"
 
 # Switch nvmap to built-in to fix the kernel headers
 SRC_URI:append = " file://0001-fix-kernel-headers-test.patch "
+SRC_URI:append:forecr-dsb-nx2-xavier-nx-emmc = " file://0001-Port-Forecr-DSBOARD-NX2-patches.patch "
 
 BALENA_CONFIGS:remove = " mdraid"
 
@@ -68,9 +69,27 @@ BALENA_CONFIGS[nfsfs] = " \
     CONFIG_NFSD_V4=y \
 "
 
+BALENA_CONFIGS:append:forecr-dsb-nx2-xavier-nx-emmc = " pcf8574 lan743x xr17v35x usbserial"
+BALENA_CONFIGS[pcf8574] = " \
+    CONFIG_GPIO_PCF857X=m \
+"
+
+BALENA_CONFIGS[lan743x] = " \
+    CONFIG_LAN743X=m \
+"
+
+BALENA_CONFIGS[xr17v35x] = " \
+    CONFIG_SERIAL_8250_XR17V35X=m \
+"
+
+BALENA_CONFIGS[usbserial] = " \
+    CONFIG_USB_SERIAL_WWAN=m \
+"
+
+
 L4TVER=" l4tver=${L4T_VERSION}"
 
-KERNEL_ARGS = " firmware_class.path=/etc/firmware fbcon=map:0 net.ifnames=0"
+KERNEL_ARGS = " firmware_class.path=/etc/firmware fbcon=map:0 "
 KERNEL_ARGS += "${@bb.utils.contains('DISTRO_FEATURES','osdev-image',' mminit_loglevel=4 console=tty0 console=ttyTCU0,115200 ',' console=null quiet splash vt.global_cursor_default=0 consoleblank=0',d)} l4tver=${L4T_VERSION} "
 
 generate_extlinux_conf() {
@@ -88,6 +107,10 @@ EOF
 
 }
 
+#do_deploy:append:forecr-dsb-nx2-xavier-nx-emmc() {
+#    cp ${WORKDIR}/tegra194-p3668-dsboard-nx2-0000.dtb "${DEPLOYDIR}"
+#}
+
 do_deploy[nostamp] = "1"
 do_deploy[postfuncs] += "generate_extlinux_conf"
 do_install[depends] += "${@['', '${INITRAMFS_IMAGE}:do_image_complete'][(d.getVar('INITRAMFS_IMAGE', True) or '') != '' and (d.getVar('TEGRA_INITRAMFS_INITRD', True) or '') == "1"]}"
-- 
2.37.2

